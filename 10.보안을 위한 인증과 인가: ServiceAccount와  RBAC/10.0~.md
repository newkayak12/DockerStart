```dockerfile
            > 보안을 위한 인증과 인가: ServiceAccount와 RBAC
    클라우드 플랫폼은 보통 수많은 사용자와 애플리케이션이 동시에 사용하는 것이 일반적이다. 사내 개발 조직에 속해 있는 여러 명의 개발자가 동시에 클라우드를 
    이용할 수도 있고, 필요에 따라서는 수십 개의 애플리케이션이 클라우드상에서 동시에 실행될 수도 있다. 쿠버네티스 또한 예외는 아니며, 여러 명의 개발자가
    쿠버네티스에 접근할 수도 있고, 각 개발자가 kubectl과 같은 명령어를 통해 애플리케이션을 동시에 배포하는 일도 빈번할 것이다.
    
    이처럼 여러 개발자와 애플리케이션이 쿠버네티스를 동시에 사용할 때 깊이 있게 고려해야할 부분 중 하나는 보안이다. 쿠버네티스는 보안 측면에서도 다양한 
    기능을 제공하고 있는데, 그중 가장 자주 사용되는 것이 RBAC(Role Based Access Control)를 기반으로 하는 Servie Account이다.
    Service Account는 사용자 또는 애플리케이션 하나에 해당하며, RBAC라는 기능을 통해 특정 명령을 실행할 수 있는 권한을 Service Account에 부여한다.
    권한을 부여받은 Service Account는 해당 권한에 해당하는 기능만 사용할 수 있게 된다. 
    
    간단히 생각하면 리눅스에서 root와 일반 유저를 나누는 기능을 쿠버네티스에서도 유사하게 사용할 수 있다고 생각하면 된다. root는 최고 권한으로 모든 기능을
    사용할 수 있지만 보안에 취약하므로 권장되지 않는다. 따라서 리눅스 일반 유저를 생성한 다음, 특정 명령어만 실행할 수 있도록 '/etc/sudoer'에 설정해서
    사용하는 방법이 일반적이다.
    
    쿠버네티스도 리눅스와 매우 유사한 원리로 사용자 및 애플리케이션의 권한을 관리한다. 지금까지 kubectl 명령어를 사용해왔던 권한은 사실 최상위에 해당하는, 
    마치 리눅스의 root와 같다. 쿠버네티스를 학습하기 위한 용도라면 상관이 없지만, 쿠버네티스의 API에 접근하는 애플리케이션을 운영 환경에 배포하거나,
    여러 명의 사용자가 동시에 쿠버네티스를 사용해야 한다면 최상위 권한을 사용하지 않는 것이 좋다. 사용자에게 필요한 권한만을 최소한으로 부여함으로써 실행할
    수 있는 기능을 제한하는 것이 바람직하다. 
    
    
                > 10.1 쿠버네티스의 권한 인증 과정
    쿠버네티스는 'kube-apiserver', 'kube-controller', 'kube-scheduler', 'etcd' 등과 같은 컴포넌트들로 구성돼 있다. 이러한 컴포넌트 중에서
    가장 자주 사용하게 될 컴포넌트는 'kube-apiserver'
    
    우리가  'kubectl' 명령어를 사용해서 쿠버네티스 기능을 실행하면 쿠버네티스 내부에서는 어떠한 일이 벌어질까?
    
                                                                        
            [사용자] -> |[http handler] -> [authentication] -> [authorization] -> [mutating admission contorller]
                        -> [validating admission controller] | -> etcd
                        
    가장 먼저 kubectl 명령어는 쿠버네티스 API 서버의 HTTP 핸들러에 요청을 전송한다. API 서버는 해당 클라이언트가 쿠버네티스 사용자가 맞는지 
    인증(authentication)을 하고 해당 기능을 실행할 권한(authorization)이 있는지 확인한다. 인증 인가에는 Service account 이외에도
    서드파티 인증 (Open Id Connect: OAUTH), 인증서 등과 같은 다양한 방법이 될 수 있다. 그 뒤에는 admission controller라는 별도의 단계를
    거친 후 비로소 요청 받은 기능을 수행한다. 
    그렇지만 지금까지 kubectl 명령어를 사용할 때는 이러한 단계를 거친적이 없는 것 같고 인증을 위한 계정도 생성한 적 없는 것 같고 계정에 권한을  부여한적도
    없는 것 같지만 설치도구를 사용해서 쿠버네티스를 설치하면 kubectl이 관리자 권한을 갖도록 되어 있기 때문이다. 이러한 설정은 '~/.kube/config'에서
    확인할 수 있다.  
```
```yaml
apiVersion: v1

clusters:
- cluster:
    certificate-authority-data: ...
    server: https://10.43.0.20:6443
name: kubernetes

contexts:
- context:
    cluster: kubernetes
    user: kubernetes-admin
  name: kuebernetes-admin@kubernetes
current-context: kubernetes-admin@kubernetes

users:
- name: kubernetes-admin
  user:
    client-certificate-data: ...
    client-key-data: ...

kind: Config
preferences: {}
```
```dockerfile
    kubectl을 사용할 때는 기본적으로 '~/.kube/config'라는 파일에 저장된 설정을 읽어 들여 쿠버네티스 클러스터를 제어한다. 이 파일에 저장된 내용 중에서
    users라는 항목에는 인증을 위한 데이터가 설정돼 있다. 'client-certificate-data'와 'client-key-data'에 설정된 데이터는 base64로 인코딩된
    인증서(공개키와 비밀키)인데, 이 키 쌍은 쿠버네티스에서 최고 권한(cluster-admin)을 갖는다. 그렇기 때문에 지금까지 아무런 문제 없이 쿠버네티스의 모든 
    명령어를 사용할 수 있었던 것이다. 
    
    기본적 설정된 '~/.kube/config' 파일에서는 인증서 키 쌍을 사용해 API 서버에 인증하지만, 이 인증 방법은 비교적 절차가 복잡하고 관리하기 어렵기 때문에
    자주 사용하는 방법은 아니다. 쿠버네티스에서 인증을 위해 인증서 키 쌍뿐만 아니라 여러 가지 방법을 사용할 수 있으며, 그 중 하나가 Service Account이다.
    
    
    
                >2. Service Account와 Role, Cluster Role
    Service Account는 체계적으로 권한을 관리하기 위한 쿠버네티스 오브젝트입니다. Service Account는 한 명의 사용자나 애플리케이션에 해당한다고 생각
    하면 이해하기 쉽다. Service Account는 네임스페이스에 속하는 오브젝트로, serviceaccount 또는 sa라는 이름으로 사용할 수 있다. 
    'kubectl get sa' 혹은 'kubectl get serviceaccount'
    
    여러분이 serviceAccount를 생성하지 않았더라도 각 네임스페이스에는 기본적으로 default라는 이름의 service account가 존재한다. kubectl create
    나 delete를 통해 간단히 service account를 생성/삭제할 수 있다. 
    
        'kubectl create sa alicek106'
    
    지금까지는 kubectl을 사용할 때  '~/.kube/config'에 저장되어 있던 관리자 권한은 인증 정보를 사용했지만, 이번에는 alicek106이라는 이름의 
    service account를 이용해서 kubectl을 사용해 볼 것이다. '--as'로 임시로 특정 service account를 사용할 수 있다.
    
        'kubectl get services --as system:serviceaccoutn:default:alicek106'
    
        {
            --as 옵션에 사용된 system:serviceaccount는 이니증을 위해 서비스 어카운트를 사용한다는 것을 나타내며, default:alicek106은 default
            네임스페이스의 alicek106 service account를 의미한다.
        }
        
    방금 생성한 alicek106 service account로 서비스 목록을 조회했지만 api 서버로부터 에러가 반환됐다. 이 service account는 default 네임스페스에서
    서비스 목록을 조회할 수 있는 권한이 아직 부여되지 않았다는 뜻이다. 따라서 service account에 적절한 권한을 부여해야만 쿠버네티스의 기능을 제대로 
    사용할 수 있다.
    
    쿠버네티스에서 권한 부여하는 방법 크게 두 가지가 있습니다. 롤(role)과 클러스터 롤(cluster role)을 이용해 권한을 설정하는 것이다. 롤과 클러스터 롤
    은 부여할 권한이 무엇인지를 나타내는 쿠버네티스 오브젝트이다. 예를 들어 '디플로이먼트를 생성할 수 있다.'라는 것도 하나의 롤이 될 수 있고, '서비스의 \
    목록을 조회한다.'라는 것도 롤이 될 수 있다. 단, 롤은 네임스페이스에 속하는 오브젝트이므로 디플로이먼트나 서비스처럼 네임스페이스에 속하는 오브젝트들에
    대한 권한을 정의할 떄 쓰인다.
    
    롤과 비슷한 쿠버네티스 오브젝트로는 클러스터 롤이 있는데, 클러스터 롤은 말 그대로 클러스터 단위의 권한을 정의할 떄 사용한다. 예를 들어 '퍼시스턴트 \
    볼륨의 목록을 조회할 수 있다.'라는 권한은 클러스터 롤로 정의할 수 있다. 또한, 네임스페이스에 속하지 않는 오브젝뿐만 아니라 클러스터 전반에 걸친 기능을
    사용하기 위해서도 클러스터 롤을 정의할 수 있으며, 여러 네임스페이스에서 반복적으로 사용되는 권한을 클러스터 롤로 만들어 재사용하는 것도 가능하다.
    
    가장 먼저 롤과 클러스터 롤을 사용해 보자. 롤은 네임스페이스에 속하지만, 클러스터 롤은 네임스페이스에 속하지 않는 전역적인 쿠버네티스 오브젝트이다. 따라서
    'kubectl get role' 명령어는 현재 네임스페이스의 롤 목록만 출력하지만, 'kubectl get clusterrole' 명령어는 클러스터 자체에 존재하는 모든
    클러스터 롤의 목록을 출력한다. 
    
            'kubectl get role'
    
    클러스터 롤은 쿠버네티스 컴포넌트가 사용하는 권한도 포함하기 때문에 꽤 많은 수의 클러스터 롤이 미리 생성돼 있다. 그중에는 이전에 Nginx 인그레스 컨트롤
    러를 사용할 때 함께 생성됐던 'nginx-ingress-clusterrole'이나, 쿠버네티스에서 관리자 권한 모든 기능을 사용할 수 있는 'cluster-admin'이라는
    클러스터 롤도 있다. 
        
            {
                '~/.kube/config' 파일에 기본적으로 설정돼 있던 인증서에는 cluster-admin 클러스터 롤이 부여돼 있다. 
            }
```
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: default
  name: service-reader
rules:
- apiGroups: [""]
  resources: ["services"]
  verbs: ["get", "list"]
```
```dockerfile
    위 YAML 파일은 서비스의 목록을 읽을 수 있는 롤을 정의한다. metadata 항목의 namespace는 롤이 생성될 네임스페이스를, name은 롤의 이름을 설정했다.
    
    - apiGruops : 어떠한 API 그룹에 속하는 오브젝트에 대해 권한을 지정할지 설정한다. API 그룹은 쿠버네티스의 오브젝트가 가지는 목적에 따라 분류되는 
    일종의 카테고리이다. 이 예시에서는 ""로 설정했는데, 이는 포드, 서비스 등이 포함된 코드 API 그룹을 의미한다. kubectl api-resources 명령어를
    사용하면 특정 쿠버네티스 오브젝트가 아닌 어떤 API 그룹에 속하는지 확인할 수 있다. 
    
            'kubectl api-resources'
        
    포드나 서비스 등은 코어 API 그룹에 속하기 때문에 아무것도 표시되지 않는다. 디플로이먼트나 레플리카셋 등은 apps라는 이름의 api 그룹에 속한다.
       
    - resources : 어떠한 쿠버네티스 오브젝트에 대해 권한을 정의할 것인지 입력한다. 위 예시에서는 서비스(services)를 다룰 수 있는 권한을 정의할 것이기
    때문에 ["services"]와 같이 설정했다. resources 항목 또한 kubectl api-resources에 출력되는 오브젝트의 이름을 적절히 사용하면 된다.
    
    - verbs: 이 롤을 부여받은 대상이 resources에 지정된 오브젝트들에 대해 어떤 동작을 수행할 수 있는지 정의한다. 위 예시는 get, list 동작을 명시
    했으므로 kubectl get services 명령어로 개별 서비스의 정보를 가져오거나 모든 서비스 목록을 확인할 수 있도록 권한이 부여된다.
    
            {
                YAML 파일에서 ["1","2"..]와 같이 대괄호를 이용한 표현은 배열과 같은 기능을 한다. verbs:["get","list"]는 아래와 같이 표현할 수
                있다. 
                
                ...
                resources: ["services"]
                  verbs:
                  - get
                    list
            } 
    따라서 이 YAML 파일에 정의된 apiGroup과 resources, verbs를 종합하면 "코어 API 그룹("")에 속하는 서비스 리소스에 대해서 get, list 실행 가능"
    이라고 해석할 수 있다. 
    
                'kubectl apply -f service-reader-role.yaml'으로 롤을 생성한다. 
                
    그렇지만 롤은 특정 기능에 대한 권한만을 정의하는 오브젝트이기 때문에 롤을 생성하는 것만으로는 service account나 사용자에게 권한이 부여되지 않는다. 
    이 롤을 특정 대상에게 부여하려면 롤 바인딩(RoleBinding)이라는 오브젝트를 통해 특정 대상과 롤을 연결해야한다. 예를 들어 service account에 롤에
    정의된 권한을 부여하려면 아래와 같은 롤 바인딩을 생성하면 된다.
```
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: service-reader-rolebinding
  nameSpace: default
subjects:
- kind: ServiceAccount    # 권한을 부여할 대상이 ServiceAccount이다.
  name: alicek106         # alicek106이라는 이름의 서비스 어카운트에 권한을 부여한다.
  namespace: default
roleRef:
  kind: Role              # Role에 정의된 권한을 부여한다. 
  name: service-reader    # service-reader라는 이름의 role을 대상(subjects)에 연결한다.
  apiGroup: rbac.authorization.k8s.io
```
```dockerfile
    롤 바인딩에서는 어떠한 대상을 어떠한 롤에 연결할 것인지 정의한다. 위 예시에서는 subjects 항목에 alicek106이라는 이름의 서비스 어카운트를, roleRef
    항목에 service-reader 롤을 지정했다. 따라서 alicek106 service account는 service-reader 롤에 정의된 권한을 사용할 수 있게 된다.
    
    롤 바인딩을 생성한 뒤 다시 alicek106 서비스 어카운트로 명령어를 실행해보자
    
        'kubectl apply -f rolebinding-service-reader.yaml'
    
    서비스의 목록을 확인할 수 있는 권한을 부여받았기 때문에 'kubectl get services' 명령어를 사용할 수 있다. 그렇지만 서비스 어카운트에 부여되지 않은
    다른 기능들은 여전히 사용할 수 없는 상태이다. 
    
        'kubectl get deployment --as system:serviceaccount:default:alicek106'
    
    롤 바인딩과 롤, 서비스 어카운트는 모두 1:1 관계가 아니라는 점에 유의해야한다. 하나의 롤은 여러 개의 롤 바인딩에 의해 참조될 수도 있고, 하나의 
    service account는 여러 개의 롤 바인딩에 의해 권한을 부여받을 수도 있다. 즉, 롤은 권한을 부여하기 위한 일종의 템플릿과 같은 역할을, 롤 바인딩은 롤과
    service account를 연결하기 위한 중간 다리 역할을 한다. 
        
        {
            롤이나 클러스터 롤에서 사용되는 verbs 항목에는 get,list,watch,create,update,patch,delete 등에서 선택해 사용할 수 있지만, 
            와일드카드를 의미하는 '*' 를 사용할 수도 있다.
            단, 특정 리소스에 한정된 기능을 사용할 때는 서브 리소스(sub resource)를 명시해야할 수도 있다. 예를 들어 'kubectl exec' 명령어로
            포드 내부에 들어가기 위한 권한을 생성하려면 포드의 하위 리소스인 'pod/exec'을 resources 항목에 정의해야 한다.
            
            {
                - apiGroups: [""]
                  resources: {'pods/exec'}
                  verbs: ["create"]
            }
        }
        
        
        
                > 롤 vs. 클러스터 롤
    앞서 설명한 것처럼 롤과 롤 바인딩은 네임스페이스에 한정되는 오브젝트이다. 따라서 롤은 포드, 서비스, 디플로이먼트 등과 같이 네임스페이스에 한정된 오브젝트
    에 대한 권한을 정의하기 위해 사용할 수 있다. 그렇지만 지금까지 다뤘던 오브젝트 중에는 노드(nodes), 퍼시스턴트 볼륨 등과 같이 네임스페이스에 종속되지 
    않는 오브젝트도 존재한다.
    
    물론
    
```