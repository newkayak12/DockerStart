```dockerfile
            > 보안을 위한 인증과 인가: ServiceAccount와 RBAC
    클라우드 플랫폼은 보통 수많은 사용자와 애플리케이션이 동시에 사용하는 것이 일반적이다. 사내 개발 조직에 속해 있는 여러 명의 개발자가 동시에 클라우드를 
    이용할 수도 있고, 필요에 따라서는 수십 개의 애플리케이션이 클라우드상에서 동시에 실행될 수도 있다. 쿠버네티스 또한 예외는 아니며, 여러 명의 개발자가
    쿠버네티스에 접근할 수도 있고, 각 개발자가 kubectl과 같은 명령어를 통해 애플리케이션을 동시에 배포하는 일도 빈번할 것이다.
    
    이처럼 여러 개발자와 애플리케이션이 쿠버네티스를 동시에 사용할 때 깊이 있게 고려해야할 부분 중 하나는 보안이다. 쿠버네티스는 보안 측면에서도 다양한 
    기능을 제공하고 있는데, 그중 가장 자주 사용되는 것이 RBAC(Role Based Access Control)를 기반으로 하는 Servie Account이다.
    Service Account는 사용자 또는 애플리케이션 하나에 해당하며, RBAC라는 기능을 통해 특정 명령을 실행할 수 있는 권한을 Service Account에 부여한다.
    권한을 부여받은 Service Account는 해당 권한에 해당하는 기능만 사용할 수 있게 된다. 
    
    간단히 생각하면 리눅스에서 root와 일반 유저를 나누는 기능을 쿠버네티스에서도 유사하게 사용할 수 있다고 생각하면 된다. root는 최고 권한으로 모든 기능을
    사용할 수 있지만 보안에 취약하므로 권장되지 않는다. 따라서 리눅스 일반 유저를 생성한 다음, 특정 명령어만 실행할 수 있도록 '/etc/sudoer'에 설정해서
    사용하는 방법이 일반적이다.
    
    쿠버네티스도 리눅스와 매우 유사한 원리로 사용자 및 애플리케이션의 권한을 관리한다. 지금까지 kubectl 명령어를 사용해왔던 권한은 사실 최상위에 해당하는, 
    마치 리눅스의 root와 같다. 쿠버네티스를 학습하기 위한 용도라면 상관이 없지만, 쿠버네티스의 API에 접근하는 애플리케이션을 운영 환경에 배포하거나,
    여러 명의 사용자가 동시에 쿠버네티스를 사용해야 한다면 최상위 권한을 사용하지 않는 것이 좋다. 사용자에게 필요한 권한만을 최소한으로 부여함으로써 실행할
    수 있는 기능을 제한하는 것이 바람직하다. 
    
    
                > 10.1 쿠버네티스의 권한 인증 과정
    쿠버네티스는 'kube-apiserver', 'kube-controller', 'kube-scheduler', 'etcd' 등과 같은 컴포넌트들로 구성돼 있다. 이러한 컴포넌트 중에서
    가장 자주 사용하게 될 컴포넌트는 'kube-apiserver'
    
    우리가  'kubectl' 명령어를 사용해서 쿠버네티스 기능을 실행하면 쿠버네티스 내부에서는 어떠한 일이 벌어질까?
    
                                                                        
            [사용자] -> |[http handler] -> [authentication] -> [authorization] -> [mutating admission contorller]
                        -> [validating admission controller] | -> etcd
                        
    가장 먼저 kubectl 명령어는 쿠버네티스 API 서버의 HTTP 핸들러에 요청을 전송한다. API 서버는 해당 클라이언트가 쿠버네티스 사용자가 맞는지 
    인증(authentication)을 하고 해당 기능을 실행할 권한(authorization)이 있는지 확인한다. 인증 인가에는 Service account 이외에도
    서드파티 인증 (Open Id Connect: OAUTH), 인증서 등과 같은 다양한 방법이 될 수 있다. 그 뒤에는 admission controller라는 별도의 단계를
    거친 후 비로소 요청 받은 기능을 수행한다. 
    그렇지만 지금까지 kubectl 명령어를 사용할 때는 이러한 단계를 거친적이 없는 것 같고 인증을 위한 계정도 생성한 적 없는 것 같고 계정에 권한을  부여한적도
    없는 것 같지만 설치도구를 사용해서 쿠버네티스를 설치하면 kubectl이 관리자 권한을 갖도록 되어 있기 때문이다. 이러한 설정은 '~/.kube/config'에서
    확인할 수 있다.  
```
```yaml
apiVersion: v1

clusters:
- cluster:
    certificate-authority-data: ...
    server: https://10.43.0.20:6443
name: kubernetes

contexts:
- context:
    cluster: kubernetes
    user: kubernetes-admin
  name: kuebernetes-admin@kubernetes
current-context: kubernetes-admin@kubernetes

users:
- name: kubernetes-admin
  user:
    client-certificate-data: ...
    client-key-data: ...

kind: Config
preferences: {}
```
```dockerfile
    kubectl을 사용할 때는 기본적으로 '~/.kube/config'라는 파일에 저장된 설정을 읽어 들여 쿠버네티스 클러스터를 제어한다. 이 파일에 저장된 내용 중에서
    users라는 항목에는 인증을 위한 데이터가 설정돼 있다. 'client-certificate-data'와 'client-key-data'에 설정된 데이터는 base64로 인코딩된
    인증서(공개키와 비밀키)인데, 이 키 쌍은 쿠버네티스에서 최고 권한(cluster-admin)을 갖는다. 그렇기 때문에 지금까지 아무런 문제 없이 쿠버네티스의 모든 
    명령어를 사용할 수 있었던 것이다. 
    
    기본적 설정된 '~/.kube/config' 파일에서는 인증서 키 쌍을 사용해 API 서버에 인증하지만, 이 인증 방법은 비교적 절차가 복잡하고 관리하기 어렵기 때문에
    자주 사용하는 방법은 아니다. 쿠버네티스에서 인증을 위해 인증서 키 쌍뿐만 아니라 여러 가지 방법을 사용할 수 있으며, 그 중 하나가 Service Account이다.
    
    
    
                >2. Service Account와 Role, Cluster Role
    Service Account는 체계적으로 권한을 관리하기 위한 쿠버네티스 오브젝트입니다. Service Account는 한 명의 사용자나 애플리케이션에 해당한다고 생각
    하면 이해하기 쉽다. Service Account는 네임스페이스에 속하는 오브젝트로, serviceaccount 또는 sa라는 이름으로 사용할 수 있다. 
    'kubectl get sa' 혹은 'kubectl get serviceaccount'
    
    여러분이 serviceAccount를 생성하지 않았더라도 각 네임스페이스에는 기본적으로 default라는 이름의 service account가 존재한다. kubectl create
    나 delete를 통해 간단히 service account를 생성/삭제할 수 있다. 
    
        'kubectl create sa alicek106'
    
    지금까지는 kubectl을 사용할 때  '~/.kube/config'에 저장되어 있던 관리자 권한은 인증 정보를 사용했지만, 이번에는 alicek106이라는 이름의 
    service account를 이용해서 kubectl을 사용해 볼 것이다. '--as'로 임시로 특정 service account를 사용할 수 있다.
    
        'kubectl get services --as system:serviceaccoutn:default:alicek106'
    
        {
            --as 옵션에 사용된 system:serviceaccount는 이니증을 위해 서비스 어카운트를 사용한다는 것을 나타내며, default:alicek106은 default
            네임스페이스의 alicek106 service account를 의미한다.
        }
        
    방금 생성한 alicek106 service account로 서비스 목록을 조회했지만 api 서버로부터 에러가 반환됐다. 이 service account는 default 네임스페스에서
    서비스 목록을 조회할 수 있는 권한이 아직 부여되지 않았다는 뜻이다. 따라서 service account에 적절한 권한을 부여해야만 쿠버네티스의 기능을 제대로 
    사용할 수 있다.
    
    쿠버네티스에서 권한 부여하는 방법 크게 두 가지가 있습니다. 롤(role)과 클러스터 롤(cluster role)을 이용해 권한을 설정하는 것이다. 롤과 클러스터 롤
    은 부여할 권한이 무엇인지를 나타내는 쿠버네티스 오브젝트이다. 예를 들어 '디플로이먼트를 생성할 수 있다.'라는 것도 하나의 롤이 될 수 있고, '서비스의 \
    목록을 조회한다.'라는 것도 롤이 될 수 있다. 단, 롤은 네임스페이스에 속하는 오브젝트이므로 디플로이먼트나 서비스처럼 네임스페이스에 속하는 오브젝트들에
    대한 권한을 정의할 떄 쓰인다.
    
    롤과 비슷한 쿠버네티스 오브젝트로는 클러스터 롤이 있는데, 클러스터 롤은 말 그대로 클러스터 단위의 권한을 정의할 떄 사용한다. 예를 들어 '퍼시스턴트 \
    볼륨의 목록을 조회할 수 있다.'라는 권한은 클러스터 롤로 정의할 수 있다. 또한, 네임스페이스에 속하지 않는 오브젝뿐만 아니라 클러스터 전반에 걸친 기능을
    사용하기 위해서도 클러스터 롤을 정의할 수 있으며, 여러 네임스페이스에서 반복적으로 사용되는 권한을 클러스터 롤로 만들어 재사용하는 것도 가능하다.
    
    가장 먼저 롤과 클러스터 롤을 사용해 보자. 롤은 네임스페이스에 속하지만, 클러스터 롤은 네임스페이스에 속하지 않는 전역적인 쿠버네티스 오브젝트이다. 따라서
    'kubectl get role' 명령어는 현재 네임스페이스의 롤 목록만 출력하지만, 'kubectl get clusterrole' 명령어는 클러스터 자체에 존재하는 모든
    클러스터 롤의 목록을 출력한다. 
    
            'kubectl get role'
    
    클러스터 롤은 쿠버네티스 컴포넌트가 사용하는 권한도 포함하기 때문에 꽤 많은 수의 클러스터 롤이 미리 생성돼 있다. 그중에는 이전에 Nginx 인그레스 컨트롤
    러를 사용할 때 함께 생성됐던 'nginx-ingress-clusterrole'이나, 쿠버네티스에서 관리자 권한 모든 기능을 사용할 수 있는 'cluster-admin'이라는
    클러스터 롤도 있다. 
        
            {
                '~/.kube/config' 파일에 기본적으로 설정돼 있던 인증서에는 cluster-admin 클러스터 롤이 부여돼 있다. 
            }
```
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: default
  name: service-reader
rules:
- apiGroups: [""]
  resources: ["services"]
  verbs: ["get", "list"]
```
```dockerfile
    위 YAML 파일은 서비스의 목록을 읽을 수 있는 롤을 정의한다. metadata 항목의 namespace는 롤이 생성될 네임스페이스를, name은 롤의 이름을 설정했다.
    
    - apiGruops : 어떠한 API 그룹에 속하는 오브젝트에 대해 권한을 지정할지 설정한다. API 그룹은 쿠버네티스의 오브젝트가 가지는 목적에 따라 분류되는 
    일종의 카테고리이다. 이 예시에서는 ""로 설정했는데, 이는 포드, 서비스 등이 포함된 코드 API 그룹을 의미한다. kubectl api-resources 명령어를
    사용하면 특정 쿠버네티스 오브젝트가 아닌 어떤 API 그룹에 속하는지 확인할 수 있다. 
    
            'kubectl api-resources'
        
    포드나 서비스 등은 코어 API 그룹에 속하기 때문에 아무것도 표시되지 않는다. 디플로이먼트나 레플리카셋 등은 apps라는 이름의 api 그룹에 속한다.
       
    - resources : 어떠한 쿠버네티스 오브젝트에 대해 권한을 정의할 것인지 입력한다. 위 예시에서는 서비스(services)를 다룰 수 있는 권한을 정의할 것이기
    때문에 ["services"]와 같이 설정했다. resources 항목 또한 kubectl api-resources에 출력되는 오브젝트의 이름을 적절히 사용하면 된다.
    
    - verbs: 이 롤을 부여받은 대상이 resources에 지정된 오브젝트들에 대해 어떤 동작을 수행할 수 있는지 정의한다. 위 예시는 get, list 동작을 명시
    했으므로 kubectl get services 명령어로 개별 서비스의 정보를 가져오거나 모든 서비스 목록을 확인할 수 있도록 권한이 부여된다.
    
            {
                YAML 파일에서 ["1","2"..]와 같이 대괄호를 이용한 표현은 배열과 같은 기능을 한다. verbs:["get","list"]는 아래와 같이 표현할 수
                있다. 
                
                ...
                resources: ["services"]
                  verbs:
                  - get
                    list
            } 
    따라서 이 YAML 파일에 정의된 apiGroup과 resources, verbs를 종합하면 "코어 API 그룹("")에 속하는 서비스 리소스에 대해서 get, list 실행 가능"
    이라고 해석할 수 있다. 
    
                'kubectl apply -f service-reader-role.yaml'으로 롤을 생성한다. 
                
    그렇지만 롤은 특정 기능에 대한 권한만을 정의하는 오브젝트이기 때문에 롤을 생성하는 것만으로는 service account나 사용자에게 권한이 부여되지 않는다. 
    이 롤을 특정 대상에게 부여하려면 롤 바인딩(RoleBinding)이라는 오브젝트를 통해 특정 대상과 롤을 연결해야한다. 예를 들어 service account에 롤에
    정의된 권한을 부여하려면 아래와 같은 롤 바인딩을 생성하면 된다.
```
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: service-reader-rolebinding
  nameSpace: default
subjects:
- kind: ServiceAccount    # 권한을 부여할 대상이 ServiceAccount이다.
  name: alicek106         # alicek106이라는 이름의 서비스 어카운트에 권한을 부여한다.
  namespace: default
roleRef:
  kind: Role              # Role에 정의된 권한을 부여한다. 
  name: service-reader    # service-reader라는 이름의 role을 대상(subjects)에 연결한다.
  apiGroup: rbac.authorization.k8s.io
```
```dockerfile
    롤 바인딩에서는 어떠한 대상을 어떠한 롤에 연결할 것인지 정의한다. 위 예시에서는 subjects 항목에 alicek106이라는 이름의 서비스 어카운트를, roleRef
    항목에 service-reader 롤을 지정했다. 따라서 alicek106 service account는 service-reader 롤에 정의된 권한을 사용할 수 있게 된다.
    
    롤 바인딩을 생성한 뒤 다시 alicek106 서비스 어카운트로 명령어를 실행해보자
    
        'kubectl apply -f rolebinding-service-reader.yaml'
    
    서비스의 목록을 확인할 수 있는 권한을 부여받았기 때문에 'kubectl get services' 명령어를 사용할 수 있다. 그렇지만 서비스 어카운트에 부여되지 않은
    다른 기능들은 여전히 사용할 수 없는 상태이다. 
    
        'kubectl get deployment --as system:serviceaccount:default:alicek106'
    
    롤 바인딩과 롤, 서비스 어카운트는 모두 1:1 관계가 아니라는 점에 유의해야한다. 하나의 롤은 여러 개의 롤 바인딩에 의해 참조될 수도 있고, 하나의 
    service account는 여러 개의 롤 바인딩에 의해 권한을 부여받을 수도 있다. 즉, 롤은 권한을 부여하기 위한 일종의 템플릿과 같은 역할을, 롤 바인딩은 롤과
    service account를 연결하기 위한 중간 다리 역할을 한다. 
        
        {
            롤이나 클러스터 롤에서 사용되는 verbs 항목에는 get,list,watch,create,update,patch,delete 등에서 선택해 사용할 수 있지만, 
            와일드카드를 의미하는 '*' 를 사용할 수도 있다.
            단, 특정 리소스에 한정된 기능을 사용할 때는 서브 리소스(sub resource)를 명시해야할 수도 있다. 예를 들어 'kubectl exec' 명령어로
            포드 내부에 들어가기 위한 권한을 생성하려면 포드의 하위 리소스인 'pod/exec'을 resources 항목에 정의해야 한다.
            
            {
                - apiGroups: [""]
                  resources: {'pods/exec'}
                  verbs: ["create"]
            }
        }
        
        
        
                > 롤 vs. 클러스터 롤
    앞서 설명한 것처럼 롤과 롤 바인딩은 네임스페이스에 한정되는 오브젝트이다. 따라서 롤은 포드, 서비스, 디플로이먼트 등과 같이 네임스페이스에 한정된 오브젝트
    에 대한 권한을 정의하기 위해 사용할 수 있다. 그렇지만 지금까지 다뤘던 오브젝트 중에는 노드(nodes), 퍼시스턴트 볼륨 등과 같이 네임스페이스에 종속되지 
    않는 오브젝트도 존재한다.
    
    물론 클러스터 수준의 오브젝트 들에 대한 접근 권한은 service account에 기본적으로 설정돼 있지 않다. 이전에 생성했던 alicek106 service account
    로 노드의 목록을 출력해보면 cluster scope의 리소스를 사용할 수 없다는 에러가 출력된다. 이와 유사하게 모든 네임스페이스의 리소스를 출력하는 명령어
    또한 에러를 출력한다.
    
        'kubectl get nodes --as system:serviceaccount:default:alicek106'
        
        'kubectl get services --as system:serviceaccount:default:alicek106 --all-namesapces'
        
    이런 경우에는 롤 대신 클러스터 롤을 사용할 수 있다. 클러스터 롤이라는 이름이 나타내는 것처럼 클러스터 롤은 클러스터 단위의 리소스에 대한 권한을 정의하기 
    위해 사용한다. 이번에는 노드의 목록을 출력하기 위한 클러스터 롤을 생성해 보자
```
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  namespace: default
  name: nodes-reader
rules:
- apiGroups: [""]
  resources: ["pods/exec"]
  verbs: ["create"]
```
```dockerfile
  클러스 롤의 YAML 파일은 이전에 생성했던 롤의 내용과 크게 다르지 않다. kind가  clusterRole로 설정됐다는 점을 제외하면 다른 부분은 거의 같다. 
  resources 항목에 nodes를, verbs에 get, list를 입력함으로써 노드의 목록을 출력할 수 있는 클러스터 롤을 정의했다. 위의 YAML로 클러스터 롤을 생성
  해보자.

        'kubectl apply -f nodes-reader-clusterrole.yaml'
        'kubectl describe clusterrole nodes-reader'
        
  롤을 사용할 때와 마찬가지로 클러스터 롤을 특정 대상에게 연결하려면 클러스터 롤 바인딩이라고 하는 쿠버네티스 오브젝트를 사용해야한다. 클러스터 롤 바인딩은
  클러스터 롤과 특정 대상을 연결하는 중간 매개체 역할을 한다. 롤 바인딩과 유사한 역할을 하지만, 클러스터 롤을 위해서 사용할 수 있다는 점에서 다르다. 
  아래의 내용으로 YAML 파일을 작성한 후, 클러스터 롤 바인딩을 생성해보자  
```
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: nodes-reader-clusterrolebinding
  namespace: default
subjects:
- kind: ServiceAccount
  name: alicek106
  namespace: default
roleRef:
  kind: ClusterRole
  name: nodes-reader
  apiGroup: rbac.authorization.k8s.io
```
```dockerfile
    'kubectl apply -f clusterrolebinding-nodes-reader.yaml'
    
    nodes-reader라는 이름의 클러스터 롤이 service account와 연결됐으므로 이제 노드의 목록을 정상적으로 출력할 수 있다. 
    
    'kubectl get nodes --as system:serviceaccount:default:alicek106'
    
        {
            디플로이먼트, 서비스 등과 같이 네임스페이스에 종속되는 쿠버네티스 오브젝트에 대해 클러스터 롤을 생성하면 모든 네임스페이스의 리소스에 대한
            권한이 부여된다. 예를 들어 클러스터 롤에 서비스 오브젝트를 정의해 사용하면 'kubectl get services...--all-namespace'와 같은
            명령어를 사용할 수 있다.
        }
        
    
    
            > 여러 개의 클러스터 롤을 조합해서 사용하기
    자주 사용되는 클러스터 롤이 있다면 다른 클러스터 롤에 포함시켜 재사용할 수 있는데, 이를 클러스터 롤 애그리케이션(aggregation)이라고 한다. 이 기능을
    사용하기 위해 간단한 클러스터 롤을 정의해보자. 
```
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: parent-clusterrole
  labels:
    rbac.authorization.k8s.io/aggregate-to-child-clusterrole: "true"
rules:
  - apiGroups: [""]
    resources: ["nodes"]
    verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: child-clusterrole
aggregationRule:
  clusterRoleSelectors:
    - matchLabels:
        rbac.authorization.k8s.io/aggregate-to-child-clusterrole: "true"
rule: [] #권한 지정 하지 않음
```
```dockerfile
    이번에는 aggregationRule.clusterRoleSelectors라는 조금 특이한 항목을 사용했다. 클러스터 롤에 포함시키고자 하는 다른 클러스터 롤을 matchLabels
    의 라벨 셀렉터로 선택하면 하위 클러스터 롤에 포함돼 있는 권한을 그대로 부여받을 수 있다. 위 예시에서는 child-clusterrole에 아무런 권한도 부여하지 
    않았지만 parent-clusterrole의 권한을 그대로 몰려받았으므로 child-clusterrole에서 nodes에 대한 get/list 권한을 얻는다. 
    
        'kubectl apply -f clusterrole-aggregation.yaml'
        'kubectl get no --as system:serviceaccount:default:node-reader-test'
    
    클러스터 롤 애그리게이션을 사용하면 여러 개의 클러스터 롤 권한을 하나의 클러스터 롤에 합쳐서 사용할 수도 있으며, 여러 단계의 클러스터 롤 권한 상속 구조를
    만들 수도 있다. 사실 기본적으로 존재하는 클러스터 롤ㄹ에서도 클러스터 롤 애그리게이션 기능을 찾아볼 수 있는데, 자동으로 생성돼 있는 admin, edit, view
    라는 이름의 클러스터 롤을 확인해 보면 view -> edit -> admin 순으로 권한이 전파되는 것을 알 수 있다.
        
        'kubectl get clusterrole view -o yaml | grep labels -F2'
        'kubectl get clusterrole edit -o yaml | grep -F3 aggregationRule'
        'kubectl get clusterrole eidt -o yaml | grep -F2 labels'
        'kubectl get clusterrole admin -o yaml | grep -F4 aggregation'
        
    이 경우에는 view 클러스터 롤에 권한을 부여하면 자동적으로 admin에도 권한이 적용된다. 
    
    
            > 3. 쿠버네티스 API 서버에 접근
            > 3.1 service account의 secret을 이용해서 쿠버네티스 API 서버에 접근
    쿠버네티스의 기능을 익히려면 kubectl을 사용하는 것이 가장 좋지만, 애플리케이션이 쿠버네티스 API를 사용해야한다면 일반적으로 kubectl이 아닌 다른 
    방법으로 API 서버에 접근할 것이다. 이번에는 쿠버네티스의 API 서버에 접근하기 위한 다른 방법을 알아본 후, API 서버에 접근할 때 어떻게 사용자를 
    인증할 수 있는지 알아보자
    
    도커 데몬의 실행 옵션에 '-H'를 추가함으로써 REST API를 사용했던 것처럼, 쿠버네티스의 API 서버도 HTTP 요청을 통해 쿠버네티스의 기능을 사용할 수 
    있도록 REST API를 제공하고 있다. 쿠버네티스의 REST API에 접근하기 위한 엔드포인트는 자동으로 개방되기 때문에 별도의 설정을 하지 않아도 
    API 서버에 접근할 수 있다.
    
    kubeadm의 경우 쿠버네티스의 마스터 IP와 6443 포트로, GKE나 kops의 경우 443 포트로 접근하면 API 서버에 연결할 수 있다. 마스터 노드에 SSH로
    직접 접속할 수 있다면 SSH로 접속한 뒤 localhost로 요청을 보내도 되지만, 원경에서 마스터 서버에 접근하고 싶다면 '~/.kube/config' 파일에서
    server 항목을 찾아 해당 주소로 요청을 보내도 된다. 단, 쿠버네티스 API 서버는 기본적으로 HTTPS 요청만 처리하도록 되어있으며, 기본적으로 보안 연결을
    위해 스스로 사인한 (self-signed) 인증서를 사용한다는 점에 유의해야 한다.
    
            {
                'curl https://localhost:6443 -k'
            }
    
    당연히 쿠버네티스의 API 서버로 요청을 전송할 때는 인증을 위한 정보를 제공해야한다. 따라서 API 서버에 접근하려면 별도의 인증 정보를 HTTP 페이로드에
    포함시켜 REST API 요청을 전송해야한다.
    
    이를 위해서 쿠버네티스는 서비스 어카운트를 위한 인증 정보를 Secret에 저장한다. service account를 생성하면 이에 대응하는 Secret이 자동으로 생성
    되며, 해당 Secret은 service account를 증명하기 위한 수단으로 사용한다. 시크릿의 목록을 출려해 보면 service account 이름으로 시작하는 secret
    이 존재할 것이다. 
    
        'kubectl get secrets'
    
    alicek106-token-nrzgb[예시]라는 이름의 시크릿뿐만 아니라 default service account에 대응하는 secret도 함께 존재한다. 
    'kubectl describe' 명령어를 이용해서 service account의 자세한 정보를 조회해보면 어떠한 secret이 service account에 연결돼 있는지 확인할 수 
    있다. 
    service account와 연결된 secret에는 ca.crt, namespace, token 총 3개의 데이터가 저장돼 있다. 이 중 ca.crt는 쿠버네티스 클러스터의 공개
    인증서를, namespace는 해당 service account가 존재하는 네임스페이스를 저장하고 있다.
    
        'kubectl describe secret alicek106-token-nrzgb'
        
    token 데이터는 쿠버네티스 API 서버와의 JWT 인증에 사용된다. 따라서 API 서버의 REST API 엔드포인트로 요청을 보낼 때, token의 데이터를 함께
    담아서 보내면 인증에 성공할 수 있다.
    API 서버로 token을 함께 전송하기 위해서 service account와 연결된 secret으로부터 token의 데이터를 가져오자. secret의 데이터를 기본적으로 
    base64로 인코딩돼 있다. 
    
        {
            export secret_name=[ 사용자의 시크릿 이름 ]
            export decoded_token=$(kubectl get secret $seret_name -0 jsonpath='{.data.token'} | base64 -d)
            # OS X 라면 base64 -D 명령어를 사용한다. 
        }
        
    디코드된 token 데이터를 HTTP 페이로드의 Bearer 헤더에 담아서 다시 API요청을 보내면 드디어 성공적으로 응답을 받을 수 있다. 
    
        {
            kubectl proxy 명령어를 이용해서 임시 프록시를 생성함으로써 API 서버에 별도의 인증 없이도 쉽게 접근할 수 있다. 단, 이 프록시는 
            기본적으로 로컬 호스트 요청만 처리할 수 있으므로 테스트 용도로 사용하는 것이 좋다. 
            
                'kubectl proxy'
        }
    
    kubectl에서 사용할 수 있는 기능은 모든 REST API에서도 동일하게 사용할 수 있다. 예를 들어 '/api/v1/namespaces/default/services' 경로로
    요청을 보내면 default 네임스페이스에 존재하는 서비스의 목록을 가져올 수 있다. 따라서 이 API 경로는 kubectl get services -n default 명령어와
    같은 기능을 하는 셈이다. 
    
      {
        curl https://localhost:6443/api/v1/namespaces/default/services -k --header "Authorization: Bearer $decoded_token"
      }
    
    그렇지만 API 서버로 REST 요청 또한 롤 또는 클러스터 롤을 통해 service account에 권한을 부여하지 않으면 접근이 불가능하다. 
    
        {
            API 서버의 몇몇 경로들은 기본적으로 service account가 접근할 수 없도록 제한돼 있다. 예를 들어 service account의 토큰을 이용해
            '/logs'나 '/metrics'에 접근하면 권한이 없다는 오류가 반환될 것이다. 이때 클러스터 롤을 사용하면 이러한 URL에도 접근할 수 있도록
            권한을 부여할 수 있다. 예를 들어, 아래의 클러스터 롤은 '/metrics'와 '/logs'에 접근할 수 있는 권한을 정한다. 
        }
```
nonresource-url-clusterrole.yaml
```yaml
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  name: api-url-access
rules:
  - nonResourceURLs: ["/metrics", "/logs"]
    verbs: ["get"]
```

```dockerfile
                > 3.2 클러스터 내부에서 kubernetes 서비스를 통해 API 서버에 접근
    사용자가 쿠버네티스의 기능을 사용하려면 kubectl이나 REST API 등의 방법을 통해 API 서버에 접근할 수 있다. 그렇다면 쿠버네티스 클러스터 내부에서
    실행되는 애플리케이션은 어떻게 API 서버에 접근하고 인증을 수행할까?
    
    
```