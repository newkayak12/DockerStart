### 2.3 도커 이미지
<pre>
    모든 컨테이너는 이미지를 기반으로 생성되므로 이미지를 다루는 방법은 도커 관리에서 빼놓을 수 없는 부분이다.
  이미지의 이름을 구성하는 저장소, 이미지 이름, 태그를 잘 관리하는 것뿐만 아니라 이미지가 어떻게 생성되고 삭제되는지,
  이미지 구조는 어떻게 돼 있는지 등을 아는 것 역시 중요하다.
    
  debian 에서 apt-get install로 apt 레포지토리에서 패키지를 내려 받고 redhat에서 yum install로 yum 레포지토리에서
  패키지를 내려받듯이 도커는 기본적으로 도커 허브(Docker Hub)라는 중앙 이미지에서 이미지를 내려받는다. 
  도커 허브는 도커가 공식적으로 제공하고 있는 이미지 저장소로서, 도커 계정을 가지고 있다면 누구든지 이미지를 올리고 내려받을 수 
  있기 때문에 다른 사람들에게 이미지를 쉽게 공유할 수 있다. 

  'docker create', 'docker run', 'docker pull'의 명령어로 이미지를 내려받을 때 도커는 도커 허브에서 해당 이미지를
  검색한 뒤 내려 받는다. 
  단, 도커 허브는 누구나 이미지를 올릴 수 있기 때문에 공식(Official) 라벨이 없는 이미지는 사용법을 찾을 수 없거나 제대로 
  동작하지 않을 수도 있다. 또한 이미지 저장소를 다른 사람에게 공개하지 않으려 private 저장소를 사용하려면 요금을 지불해야한다.
  이를 위해서 도커 사설 저장소를 구축해서 사용할 수도 있다.
 'docker search'를 통해서 허브에서 이미지를 검색하며, 도커 허브 이미지임을 명시하게 위해 'docker.io/ubuntu'와 같이 
 'docker.io' 접두어를 사용할 수도 있다. 이는 구글 이미지 레지스트리(gcr.io) 등과 같은 다른 이미지 저장소와 구분하기 위함이다.
</pre>
|              NAME               |                  DESCRIPTION                   | STARS  | OFFICIAL  | AUTOMATED  |
|:-------------------------------:|:----------------------------------------------:|:------:|:---------:|:----------:|    
|            ubuntu            | Ubuntu is a Debian-based Linux operating sys…  | 14045  |   [OK]    ||
|       websphere-liberty      | WebSphere Liberty multi-architecture images …  |  283   |   [OK]    ||
|        ubuntu-upstart        | DEPRECATED, as is Upstart (find other proces…  |  112   |   [OK]    ||
|          neurodebian         | NeuroDebian provides neuroscience research s…  |   88   |   [OK]    ||
|         open-liberty         | Open Liberty multi-architecture images based…  |   51   |   [OK]    ||
|      ubuntu-debootstrap      |        DEPRECATED; use "ubuntu" instead        |   46   |   [OK]    ||
|         ubuntu/nginx         | Nginx, a high-performance reverse proxy & we…  |   40   |||
|         ubuntu/mysql         | MySQL open source fast, stable, multi-thread…  |   29   |||
|        ubuntu/apache2        | Apache, a secure & extensible open-source HT…  |   26   |||
|       ubuntu/prometheus      | Prometheus is a systems and service monitori…  |   23   |||
| kasmweb/ubuntu-bionic-desktop| Ubuntu productivity desktop for Kasm Workspa…  |   22   |||
|         ubuntu/squid         | Squid is a caching proxy for the Web. Long-t…  |   18   |||
|        ubuntu/postgres       | PostgreSQL is an open source object-relation…  |   15   |||
|         ubuntu/bind9         | BIND 9 is a very flexible, full-featured DNS…  |   13   |||
|         ubuntu/redis         | Redis, an open source key-value store. Long-…  |   9    |||
|        ubuntu/grafana        | Grafana, a feature rich metrics dashboard & …  |   5    |||
|ubuntu/prometheus-alertmanager| Alertmanager handles client alerts from Prom…  |   5    |||
|       ubuntu/memcached       | Memcached, in-memory keyvalue store for smal…  |   4    |||
|        ubuntu/telegraf       | Telegraf collects, processes, aggregates & w…  |   3    |||
|    circleci/ubuntu-server    |         This image is for internal use         |   3    |||
|         ubuntu/cortex        | Cortex provides storage for Prometheus. Long…  |   2    |||
|       ubuntu/cassandra       | Cassandra, an open source NoSQL distributed …  |   1    |||
| bitnami/ubuntu-base-buildpack|         Ubuntu base compilation image          |   0    |           |    [OK]    |
|          snyk/ubuntu         | A base ubuntu image for all broker clients t…  |   0    |||
|     rancher/ubuntuconsole    |                                                |   0    |||

### 2.3.1 도커 이미지 생성
```dockerfile
    앞에서처럼 'docker search'를 통해 검색한 이미지를 pull 명령어로 내려받아 사용할 수도 있지만 도커로 개발하는 많은 경우
    컨테이너에 애플리케이션을 위한 특정 개발 환경을 직접 구축한 뒤 사용자만의 이미지를 직접 생성해야한다. 
    
    아래의 명령어를 입력해서 이미지로 만들 컨테이너를 생성한다. 컨테이너 내부에 first라는 이름의 파일을 하나 생성해 기존 이미지로부터
    변경사항을 만든다.
    
    'docker run -i -t --name commit_test ubuntu:14.04'
    'echo test_first! >> first'

    first라는 파일을 만들어 ubuntu:14.04 이미지로부터 변경 사항을 만들었다면 컨테이너에서 호스트로 빠져나와 docker commit
    명령어를 입력해서 컨테이너를 이미지로 만든다. 
    
    'docker commit [options] container [repository[:tag]]'
    
    'docker commit \
    -a "alicek106" -m "my first commit " \
    commit_test \
    commit_test:first '
    
    저장소 이름은 입력하지 않아도 상관없지만 이미지의 태그를 입력하지 않으면 자동으로 latest로 설정된다.
    '-a' 옵션은 author을 뜻하며 이미지의 작성자를 나타내는 메타데이터를 이미지에 포함시킵니다.
    '-m' 옵션은 커밋 메시지를 뜻하며, 이미지에 포함될 부가 설명을 입력합니다.
    
    커밋된 이미지는 docker images 명령어로 확인할 수 있습니다. 
```

### 2.3.2 이미지 구조 이해
```dockerfile
    위와 같이 컨테이너를 이미지로 만드는 작업은 commit으로 쉽게 수행할 수 있다. 그러나 이미지를 좀더 효율적으로 다루기 위해서 
    컨테이너가 어떻게 이미지로 만들어지며, 이미지의 구조는 어떻게 돼 있는지 알 필요가 있다.
    
    {
        inspect 명령어는 컨테이너뿐만 아니라 네트워크, 볼륨, 이미지 등 모든 도커 단위의 정보를 얻을 때 사용할 수 있다. 
        단, 이름이 중복될 경우 컨테이너에 대해 먼저 수행되므로 --type을 명시하는 것이 좋다. 
    }
    
    Layers를 보면
    "Layers": [
                "sha256:59199d90878e4fda42bcd8a43bfe3ecd964265b2008746c6b18ae3d6ca659033",
                "sha256:adbc84b28930199a1937b64d4c2eb433b09ddf5b917eee0ba817bc85d94684c7",
                "sha256:f244924ab727eda9f71f93dad47e0b4bad8e6e6ee9471374134d725102a26a16"
            ]
    이미지를 커밋할 때 컨테이너에 변경된 사항만 새로운 레이어로 저장하고, 그 레이어를 포함해 새로운 이미지를 생성한다. 
    초기 이미지가 200mb이면 초기 + 첫 번째 커밋 + 두 번째 커밋 용량이 파일 크기가 되는 식이다. 
    
    'docker rmi' 명령어를 사용하면 이미지를 삭제할 수 있다. 그러나 이미지를 사용 중인 컨테이너가 존재한다면
    해당 이미지를 삭제할 수 없다는 내용의 문구를 출력한다. 
    {
        'docker rmi -f'로 강제 삭제하면 이미지의 이름이 <none>으로 변경되며, 이러한 이미지들을 dangling 이미지라고 한다.
        댕글링 이미지는 'docker images -f dangling=true' 명령어를 사용해서 확인할 수 있다.
        사용 중이지 않은 댕글링 이미지는 docker image prune 명령어로 한꺼번에 삭제할 수 있다.
    }
    만약 '-f'로 강제로 삭제하게 하더라도 이미지 이름만 삭제하게 된다. 따라서 이미지를 사용 중인 컨테이너를 중지, 삭제한 후
    이미지를 삭제해야한다.
    
        'docker stop [컨테이너 이름]&&docker rm [컨테이너 이름]'
        'docker rmi 이미지 이름:태그' 
    
    이미지를 삭제했다고 해서 실제로 해당 이미지의 레이어 파일이 삭제되지는 않는다. commit_test:first 이미지를 기반으로 하는 
    하위 이미 이미지인 commit_test:second가 존재하기 때문이다. 따라서 실제 이미지 파일을 삭제하지 않고 레이어에 부여된 이름만
    삭제한다. 'rmi'의 출력 결과인 Untagged:... 는 이미지에 부여된 이름만 삭제한다는 뜻이다.
    
        'docker rmi commit_test:second'
    를 사용하면 하위 이미지가 없기 때문에 바로 삭제할 수 있다. 즉, 삭제되는 이미지의 부모 이미지가 존재하지 않아야만 해당 이미지 파일이
    실제로 삭제된다.
```

### 2.3.3 이미지 추출
```dockerfile
    도커 이미지를 별도로 저장하거나 옮기는 등 필요에 따라 이미지를 단일 바이너리 파일로 저장해야할 때가 있다. 'docker save' 명령어
    를 통해서 컨테이너의 커맨드, 이미지 이름과 태그 등 이미지의 모든 메타데이터를 포함해 하나의 파일로 추출할 수 있다. '-o' 옵션에는
    추출될 파일명을 입력한다.
    
        'docker save -o ubuntu_14_04.tar' ubuntu:14.04
    
    추출된 이미지는 load 명령어로 도커에 다시 로드할 수 있다. save 명령어로 추출된 이미지는 이미지의 모든 메타데이터를 포함하기 
    때문에  load 명령어로 이미지를 로드하면 이전의 이미지와 완전히 동일한 이미지가 도커 엔진에 생성된다.
    
        'docker load -i ubuntu_14_04.tar'
        
    'save', 'load'와 유사하게 사용할 수 있는 명령어로 export, import가 있다. 'docker commit' 명령어로 컨테이너를 이미지로
    만들면 컨테이너에서 변경된 사항뿐만 아니라 컨테이너가 생성될 때 설정된 detached 모드, 컨테이너 커맨드와 같은 컨테이너 설정 등도 
    이미지에 함께 저장된다. 그러나 export 명령어는 컨테이너의 파일 시스템을 tar로 추출하여 컨테이너 및 이미지에 대한 설정 정보를
    저장하지는 않는다.
    
    export와 import는 단일 파일로 추출하고 이를 이미지로 저장하는 등에 사용합니다. 그러나 이미지를 단일 파일로 저장하는 것은 
    효율적인 방법은 아니다. 레이어 구조의 파일이 아닌ㄴ 단일 파일이기 때문에 여러 버전의 이미지를 추출하면 이미지 용량을 각기
    차지하게 된다. 
```
### 2.3.4 이미지 배포
```dockerfile
    이미지를 생성했다면 이를 다른 도커 엔진에 배포할 방법이 필요하다. 'save', 'export'와 같은 방법으로 이미지를 단일 파일로 
    추출해서 배포할 수도 있지만 이미지 파일의 크기가 너무 크거나 도커 엔진수가 많다면 이미지를 파일로 배포하기 어렵다. 또한 도커의
    이미지 구조인 레이어 형태를 이용하지 않으므로 매우 비효율적이다.
    
    이를 해결하는 첫 번째 방법은 도커에서 공식적으로 제공하는 도커 허브 이미지 저장소를 사용하는 것이다. 도커 허브는 도커 이미지를
    저장하기 위한 클라우드 서비스라고 생각하면 이해하기 쉽다. 사용자는 이미지를 올리고 (docker push) 내려받기 (docker pull)
    만 하면 되므로 매우 간단하게 사용할 수 있다. 
    
    두 번째 방법은 도커 사설 레지스트리 (Docker Private Registry)를 사용하는 것으로서 사용자가 직접 이미지 저장소를 만들 수 
    있다. 그러나 사용자가 직접 이미지 저장소 및 사용되는 서버, 저장 공간 등을 관리해야 하므로 도커 허브보다는 사용 방법이 까다롭다.
    
    
    이미지를 만들고 
        'docker run -t -i --name commit_container1 ubuntu:14.04'
        'echo my first push >> test'
        
        'docker commit commit_container1 my-image-name:0.0'
        
        'docker tag my-image-name:0.0 alicek107/my-image-name:0.0'
        
        'docker push alicek107/my-image-name:0.0'
    와 같이 푸시하면 저장소에 이미지가 올라간다.
```