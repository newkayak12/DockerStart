# 도커 스웜

### 3.1 도커 스웜을 사용하는 이유
```dockerfile
    지금까지 알아본 도커 사용법은 대부분 하나의 호스트를 기준으로 한다. 'docker ps' 명령어는 하나의 도커 엔진에 존재하는 컨테이너의 목록을 출력하며, 
    create, run 명령어 또한 하나의 도커 엔진에 컨테이너를 생성한다. 그러나 실제로 도커를 운영 환경에 적용하면 조금 이야기가 달라진다. 하나의 호스트
    머신에서 도커 엔진을 구동하다 CPU, 메모리 등의 자원이 부족하면 어떻게 할까?
    
    가장 많이 사용하는 방법은 여러 대의 서버를 클러스터로 만들어 자원을 병렬화하는 것이다. 그러나 여러 대의 서버를 하나의 자원 풀로 만드는 것은 쉽지 않다.
    새로운 서버나 컨테이너가 추가됐을 때 이를 발견(Service Discovery)하는 작업부터 어떤 서버에 컨테이너를 할당할 것인가에 대한 스케쥴러와 로드밸런싱
    문제 클러스터 내의 서버가 다운됐을 때 고가용성(High Availbility)을 어떻게 보장할지 등이 문제로 남아있다. 이러한 문제를 해결 할 수 있는 
    대표적인 것이 도커에서 공식적으로 제공하는 docker swarm과 swarm mode이다.
```

### 3.2 스웜 클래식과 도커 스웜모드
```dockerfile
    스웜 클래식과 스웜 모드는 여러 대의 도커 서버를 하나의 클러스터로 만드렁 컨테이너를 생성하는 여러 기능을 제공한다. 다양한 전략을 세워 컨테이너를
    특정 도커 서버에 할당할 수 있고 유동적으로 서버를 확장할 수도 있다. 그뿐만 아니라 스웜 클러스터에 등록된 서버의 컨테이너를 쉽게 관리할 수 있다.
    따라서 PaaS와 같은 용도로 도커 서버 클러스터링을 고려한다면 스웜이 적격이다.
    
    도커 스웜에는 두 가지 종류가 있다. 첫 번째는 도커 버전 1.6 이후부터 사용할 수 있는 컨테이너로서의 스웜이고 ('스웜 클래식'), 두 번째는 도커 버전 
    1.12 이후로부터 사용할 수 있는 도커 스웜 모드이다.('스웜 모드') 
    
    스웜 클래식과 스웜 모드의 가장 큰 차이점은 그 목적에 있다. 스웜 클래식은 여러 대의 도커 서버를 하나의 지점에서 사용하도록 단일 접근점을 제공한다면
    스웜 모드는 마이크로서비스 아키텍처의 컨테이너를 다루기 위한 클러스터링 기능에 초점을 맞추고 있다. 스웜 클래식은 docker run, docker ps 등
    일반적인 도커 명려어와 도커 API로 클러스터의 서버를 제어하고 관리할 수 있는 기능을 제공한다. 이에 비해 스웜 모드는 같은 컨테이너를 동시에 여러 개
    생성해 필요에 따라 유동적으로 컨테이너의 수를 조절할 수 있으며, 컨테이너로의 연결을 분산하는 로드밸런싱 기능을 자체적으로 제공합니다. 개발하는 애플리케
    이션의 특성에 따라 적절한 것을 선택해 사용하면 되지만, 스웜 모드가 서비스 확장성과 안정성 등 여러 측면에서 스웜 클래식보다 뛰어나기 때문에 일반적으로
    스웜모드를 더 많이 사용한다. 
    
    스웜 클래식과 스웜 모드의 차이점은 분산 코디네이터(Distributed Coordinator), 에이전트와 같은 클러스터 툴이 별도로 구동되느냐이다. 여러 개의
    도커 서버를 하나의 클러스터로 구성하려면 각종 정보를 저장하고 동기화하는 분산 코디네이터, 클러스터 내의 서버를 관리하고 제어하는 매니저, 각 서버를 제어
    하는 에이전트가 반드시 있어야 한다. 스웜 클래식은 분산 코디네이터, 에이전트 등이 별도로 실행돼야 하지만, 스웜 모드는 클러스터링을 위한 모든 도구가 
    도커 엔진 자체에 내장돼 있기 때문에 더욱 쉽게 서버 클러스터를 구축할 수 있다.
    
    {
        분산 코디네이터는 클러스터에 영입할 새로운 서버 발견, 클러스터의 각종 설정 저장, 데이터 동기화 등에 주로 이용된다. etcd, zookeeper, consul
        등이 대표적인 예시이며, 스웜 클래식은 대부분 분산 코디네이터를 사용할 수 있다. 스웜 모드는 분산 코디네이터를 별도로 구축하지 않아도 된다. 
    }
    
    대규모 클러스터에서 서비스를 운영하는 것을 계획하고 있다면 스웜 클래식보다는 스웜모드를 사용하는 것이 좋다. 스웜 모드는 마이크로서비스 아키텍처 애플리
    케이션을 컨테이너로 구축할 수 있도록 도와줄 뿐만 아니라, 서비스 장애에 대비한 고가용성 부하 분산을 위한 로드밸런싱 기능 또한 제공하고 있기 때문이다. 
    스웜 클래식을 사용해서 도커 클러스터를 구축하는 것이 불가능한 것은 아니지만, 스웜 모드를 사용하면 더욱 많은 기능을 손쉽게 사용할 수 있기 때문에
    가능하다면 스웜모드를 사용하는 것이 좋다. 
```

### 3.3 스웜 모드
```dockerfile
    스웜모드는 별도의 설치 과정이 필요하지 않으며, 도커 엔진 자체에 내장돼 있다. docker info 명령어를 통해 도커 엔진의 스웜 모드 클러스터 정보를 확인
    할 수 있다.
        {
            서버 클러스터링을 할 때는 반드시 각 서버의 시각을 NTP 등의 툴을 이용해서 동기화해야 한다. 서버 간의 설정된 시각이 다를 경우 
            예상치 못한 오류가 발생할 수 있다.        
        }
```
#### 3.3.1 도커 스웜 모드의 구조
```dockerfile
    스웜 모드는 매니저 노드와 워커 노드로 구성돼 있다. 워커 노드는 실제로 컨테이너가 생성되고 관리되는 도커 서버이고 매니저 노드는 워커 노드를 관리하기 위한
    도커 서버이다. 그렇지만 매니저 노드에도 컨테이너가 생성될 수 있다. 즉, 매니저 노드는 기본적으로 워커 노드의 역할을 포함하고 있다.
    매니저 노드는 1개 이상 있어야 하지만 워커 노드는 없을 수도 있다. 이는 매니저 노드가 워커 노드의 역할도 포함하고 있어 매니저 노드만으로 스웜 클러스터를
    구성할 수 있기 때문이다. 그러나 일반적으로 워커 노드와 매니저 노드를 구분해서 사용하는 것이 좋다.
    
    실제 운영환경에서 스웜모드로 도커 클러스터를 구성하려면 매니저 노드를 다중화하는 것이 좋다. 이렇게 하면 매니저의 부하를 분산하고 특정 매니저 노드가
    다운됐을 떄 정상적으로 스웜 클러스터를 유지할 수 있기 떄문이다. 그러나 매니저 수를 늘린다고 스웜 클러스터의 성능이 좋아지는 것은 아니다.
    
    스웜 모드는 매니저 노드의 절반 이상에 장애가 생겨 정상적으로 작동하지 못할 경우 장애가 생긴 매니저 노드가 복구될 때까지 클러스터 운영을 중단한다. 
    만약 매니저 노드 사이에 네트워크 파티셔닝과 같은 현상이 발생했을 경우 짝수 개의 매니저로 구상한 클러스터는 운영이 중단될 수도 있지만 홀수로 구성했
    을 경우 과반수 이상이 유지되는 쿼럼 매니저에서 운영을 계속할 수 있다. 따라서 스웜 매니저는 가능한 홀수 개로 구성하는 것이 좋다. 
```

#### 3.3.2 도커 스웜 모드 클러스터 구축
```dockerfile
    'docker swarm init'으로 매니저 역할을 할 서버에서 스웜 클러스터를 시작한다. '--advertise-addr'에는 다른 도커 서버가 매니저 노드에 
    접근하기 위한 IP주소를 입력한다.
    
        'docker swarm init --advertise-addr 192.168.0.100'
        
    출력 결과 중 docker swarm join 명령어는 새로운 워커 노드를 스웜 클래스터에 추가할 때 사용된다. --token 옵션에 사용된 토큰 값은 새로운 노드를 
    해당 스웜 클러스터에 추가하기 위한 비밀 키이다. 
    
    {
        스웜 매니저는 기본적으로 2377번 포트를 사용하며 노드 간 통신에 7946/tcp, 7946/udp 포트를, 스웜이 사용하는 네트워크인 ingress 오버레이
        네트워크게 4789/tcp, 4789/udp 포트를 사용한다. 스웜 클러스터를 구성 하기 전에 이러한 포트를 각 호스트 머신에서 열어두는 것이 필요하다.
    }
    
        'docker swarn join \
        --token [토큰] \
        [IP]:[Port]'
        
    특정 도커 서버가 정상적으로 스웜 클러스터에 추가됐는지 확인하려면 매니저 노드에서 docker node ls 명령어를 입력한다. 별표(*)가 붙어 있는 노드가
    현재 서버이다. 
    
    {
        매니저 노드는 일반적인 매니저 역할을 하는 노드와 리더 역할을 한는 노드로 나뉜다. 리더 매니저는 매니저 노드에 대한 데이터 동기화와 관리를 담당
        하므로 항상 작동할 수 있는 상태여야 한다. 리더 매니저의 서버가 다운되는 등의 장애가 생기면 매니저는 새로우 ㄴ리더를 선출하는데, 이때 Raft 
        Consensus 알고리즘을 사용한다. 
    }
    
    새로운 매니저 노드를 추가하려면 매니저 노드를 위한 토큰을 사용해 docker swarm join 명령어를 사용한다. 매니저 노드를 추가하기 위한 토큰은
    docker swarm join-token manager 명령어로 확인할 수 있다. 이와 마찬가지로 워커 노드를 추가하기 위한 토큰도 docker swarm join-token
    worker 명령어로 확인할 수 있다.
    
        'docker swarm join-token manager'
        'docker swarm join \ 
        --token [TOKEN] \
        [IP]:[PORT]'
    
    이 토큰은 외부에 노출되지 않도록 주의하는 것이 좋다. 스웜 클러스터에 새로운 노드를 추가하는 토큰이 공개되면 누구든지 해당 스웜 클러스터에 노드를 
    추가할 수 있게 되고, 보안 측면에서 문제가 될 수 있기 떄문이다. 따라서 실제 운영 환경에서 주기적으로 스웜 클러스터의 토큰을 변경하는 것이 안전하다.
    
    토큰을 갱신하려면 swarm join 명령어에 --rotate 옵션을 추가하고 변경할 토큰의 대상을 입력하면 된다. 단, 이 작업은 매니저 노드에서만 수행할 수 
    있다. 다음은 매니저 노드를 추가하는 토큰을 변경하는 예시이다.
    
        'docker swarm join-token --rotate manager'
        
    {
        docker info 명령어를 사용해도 스웜 클러스터의 정보를 확인할 수 있으며, 출입되는 대부분의 값은 docker swarm init의 추가적인 옵션을
        통해 설정할 수 있다.
    }
    
    추가된 워커 노드를 삭제하고 싶으면 해당 워커 노드에서 docker swarm leave 명령어를 입력한다. 특정 워커 노드가 leave 명령어로 스웜 모드를 해제하면
    매니저 노드는 해당 워커 노드의 상태를 Down으로 인지할 뿐 자동으로 워커노드를 삭제하지 않는다. 따라서 매니저 노드에서 docker node rm 명령어를
    사용해서 해당 워커 노드를 삭제해야 한다. 
    
    {
        컨테이너를 다룰 때 컨테이너의 이름이 아닌 ID의 일부를 사용한 것처럼 도커에서 ID가 부여되는 대부분의 단위는 ID의 앞자리 일부만 사용해 제어할 수 
        있다. 예를 들어, 위의 docker node rm 명령어는 아래와 같이 쓸 수 있다.
        
            'docker node rm 9cb0'
    }
    
    매니저 노드는 docker swarm leave 명령어에 --force 옵션을 추가해야만 삭제할 수 있다. 매니저 노드를 스웜 클러스터에서 삭제하면 해당 매니저 노드
    에 저장돼 있던 클러스터의 정보도 삭제되므로 주의해야한다. 스웜 클러스터에 매니저 노드가 단 핸 개 존재할 때 매니저 노드를 삭제하면 해당 스웜 클러스터는
    더 이상 사용 불능 상태가 된다. 
    
        'docker swarm leave --force'
        
    워커 노드를 매니저 노드로 변경하려면 'docker node promote' 명령어를 사용한다. 이와 반대로 매니저 노드를 워커 노드로 변경하려면 
    'docker node demote' 명령어를 사용하면 된다. 단, 매니저 노드가 1개일 때 매니저 노드에 대해서 demote를 사용할 수 없다.  매니저 리더 노드에
    'demote' 명령어를 사용하면 다른 매니저 노드 중 새로운 리더를 선출한다.
```

### 3.3.3 스웜 모드 서비스
#### 3.3.3.1 스웜 모드 서비스 개념
```dockerfile
    스웜 모드에서 제어하는 단위는 컨테이너가 아닌 서비스(service)이다. 서비스는 같은 이미지에서 생성된 컨테이너의 집합이며, 서비스를 제어하면 해당 서비스
    내의 컨테이너에 같은 명령이 추가된다. 서비스 내의 컨테이너는 1개 이상 존재할 수 없으며, 컨테이너들은 각 워커 노드와 매니저 노드에 할당된다. 
    이러한 컨테이너들을 태스크(Task)라고 한다.
    
    예를 들어, ubuntu:14.04 이미지로 서비스를 생성하고 컨테이너 수를 3개로 설정했다고 가정했을때 Swam Schduler는 서비스의 정의에 따라 컨테이너를
    할당할 적합한 노드를 선정하고, 해당 노드에 컨테이너를 분산해서 할당한다. 그러나 반드시 각 노드에 하나씩 할당되지 않을 수도 있다.
    
    이처럼 함께 생성된 컨테이너를 레플리카(Replica)라고 하며, 서비스에 설정된 레플리카의 수만큼의 컨테이너가 스웜 클러스터 내에 존재해야한다.
    
    스웜은 서비스의 컨테이너들에 대한 상태를 계속 확인하고 있다가 서비스 내에 정의된 레플리카의 수만큼 컨테이너가 스웜 클러스터에 존재하지 않으면 새로운
    컨테이너 레플리카를 생성한다. 컨테이너가 할당된 노드가 다운되면 매니저는 사용 가능한 다른 노드에 같은 컨테이너를 생성한다. 서버가 다운되지 않더라도
    서비스 내의 컨테이너 중 일부가 작동을 멈춰 정지한 상태로 있다면 이 또한 레플리카의 수를 충족하지 못하는 것으로 판단해 스웜 매니저는 새로운 컨테이너를
    클러스터에 새롭게 생성한다.
    
    서비스는 롤링 업데이트(Rolling Update) 기능도 제공한다. 서비스 내 컨테이너들의 이미지를 일괄적으로 업데이트해야 할 때 컨테이너들의 이미지를 순서대로
    변경해 서비스 자체가 다운되는 시간 없이 컨테이너의 업데이트를 진행할 수 있다. 
    {
        롤링 업데이트는 여러 개의 서버, 컨테이너 등으로 구성된 클러스터의 설정이나 데이터 등을 변경하기 위해서 하나씩 재시작하는 것을 의미한다. 롤링 
        업데이트를 사용하지 않고 모든 서버나 컨테이너를 한 번에 재시작하면 제공하는 서비스에 다운 시간이 생기지만 롤링 업데이트를 이용하면 하나를 업데이트
        해도 다른 서버나 컨테이너는 작동 중이기 때문에 지속적인 서비스가 가능하다. 
    }
```
#### 3.3.3.2 서비스 생성
```dockerfile
    서비스를 제어하는 도커 명령어는 전부 매니저 노드에서만 사용할 수 있다.
    
    1. 첫 번쨰 서비스 생성하기
    서비스를 사용하기 위한 명령어는 docker service로 시작한다. 서비스를 생성하려면 docker service create 명령어를 사용한다. docker servcie
    create 명령어도 run 명령어와 비슷한 형식을 띤다.
    
        'docker service create \
        ubuntu:14.04 \
        /bin/sh -c "while true; do echo hello world; sleep 1; done"'
    
    {
        서비스 내의 컨테이너는 detached 모드로, 즉 docker run 명령어의 -d 옵션을 사용해 동작할 수 있는 이미지를 사용해야 한다. 위 예시는 우분투
        컨테이너 내에서 계속 'hello world'를 출려하기 때문에 컨테이너가 서비스로서 정상적으로 동작한다. 
        그러나 'docker service create ubuntu:14.04'로 서비스를 생성하면 컨테이너 내부를 차지하고 있는 프로세스가 없어서 컨테이너가 정지될 
        것이고, 스웜 매니저는 서비스의 컨테이너에 장애가 생긴 것으로 판단해 컨테이너를 계속 반복해서 생성할 것이다.  
    }
    
    서비스를 생성했다면 서비스의 목록을 확인해 방금 생성한 서비스가 정상적으로 구동하고 있는지 확인한다.  스웜 클러스터 내의 서비스 목록은 
    'docker service ls' 명령어로 확인할 수 있다. run 명령어를 사용했을 때처럼 서비스의 이름을 따로 정의하지 않았기 떄문에 서비스의 이름이 무작위로
    설정된 것을 알 수 있다. 
    
    서비스의 자세한 정보를 확인하려면 'docker service ps [서비스 이름]'과 같이 입력한다. 이 명령어로 서비스 내의 컨테이너 목록, 상태, 컨테이너가
    할당된 노드의 위치를 알 수 있다. 
    
    생성된 서비스를 삭제하려면 docker service rm 명령어를 입력한다. 'docker rm' 명령어를 컨테이너가 실행 중이면 삭제할 수 없던 것과 달리, 
    'docker service rm' 명령어를 사용하면 서비스의 상태에 관계 없이 서비스의 컨테이너를 바로 삭제한다. 
        
        'docker service rm [서비스 이름]'
    
    
    2. nginx 웹 서버 서비스 생성하기
    이번에는 'docker service create' 명령어에 --replica 옵션을 추가하고 Nginx 웹 서버 이미지를 이용해 서비스를 외부에 노출해보겠다.
    다음 예제는 2개의 레플리카 컨테이너를 정의하고 서비스의 이름을  myWeb으로 설정하며 컨테이너의 80번 포트를 각 노드의 80번 포트로 연결하는 서비스를
    생성한다. 생성된 서비스의 컨테이너는 'docker service ps [서비스 이름]'으로 확인할 수 있다.
        
        'docker service create --name myweb \
        --replicas 2 \
        -p 80:80
        nginx'
        
    'docker service create' 명령어도 'docker run'과 마찬가지로 도커 데몬에 이미지가 없다면 자동으로 pull을 한다. 컨테이너가 정상적으로
    생성되면 스웜 클러스터 내의 노드 중 하나를 선택해 80번 포트로 접근해 Nginx가 구동되고 있는 것을 확인할 수 있다. 그렇다고 꼭 한 노드를 선택해서
    접근해야만 하는 것은 아니다. 'docker service create' 명령어에서 -p 80:80을 입력했기 때문에 스웜 클러스터 자체의 포트를 개방했다고 
    생각하면 된다. 스웜 클러스터 내의 어떠한 노드로 접근해도 접근할 수 있다. swarm-worker2, swarm-worker1, swarm-manager 노드의 IP로 접근
    해도 동일하게 서비스를 접근할 수 있다.
    
    서비스 내의 Nginx 컨테이너를 늘리려면 'docker service scale' 명령어를 입력하면 레플리카 셋의 수를 늘리거나 줄일 수 있다.
        
        'docker service scale myweb=4'
    
    node를 확인하면 swarm-worker2로 컨테이너가 늘어난 것을 알 수 있다. 
    
    {
        스웜 모드는 라운드 로빈(Round-robin)방식으로 서비스 내에 접근할 컨테이너를 결정한다. 각 노드의 트래픽이나 자원 사용량 등을 고려해 로드
        밸런싱을 해야한다면 이 방식은 적합하지 않을 수 있다. 
    }
    
    
    3. global 서비스 생성하기 
    서비스의 모드는 두 가지가 있다. 하나는 위에서 생성한 Nginx 웹 서버 서비스와 같이 레플리카셋의 수를 정의해 그만큼 같은 컨테이너를 생성하는
    복제모드(replicated)로서 실제 서비스를 제공하기 위해 일반적으로 쓰인다. 
    
    다른 하나는 글로벌(global) 모드이다. 글로벌 서비스는 스웜 클러스터 내에서 사용할 수 있는 모든 노드에 컨테이너를 반드시 하나씩 생성한다. 따라서 
    글로벌 모드로 생성한 서비스는 레플리카 셋의 수를 별도로 지정하지 않는다. 글로벌 서비스는 스웜 클러스터를 모니터링하기 위한 에이전트 컨테이너 등을
    생성해야 할 때 유용하다. 
    
    글로벌 서비스는 'docker service create' 명령어에 --mode global을 추가해서 생성할 수 있다. --mode 옵션의 값을 별도로 설정하지 않으면
    기본적으로 복제 모드를 사용한다. 
        
        'docker service create --name global_web \
        --mode global \
        nginx'
    
    'docker service ls' 명령어와 ps 명령어로 글로벌 서비스의 상태를 확인하면 레플리카의 값이 global로 설정돼 있으며, 각 노드에 컨테이너가 하나씩
    생성됐음을 확인할 수 있다. 
    
        'docker service ls'
        
        'docker service ps global_web'
```

#### 3.3.3.3 스웜 모드의 서비스 장애 복구
```dockerfile
    복제모드로 설정된 서비스의 컨테이너가 정지하거나 특정 노드가 다운되면 스웜 매니저는 새로운 컨테이너를 생성해 자동으로 이를 복구한다. 
    
    {
        docker ps 같은 도커 클라이언트 명령어로도 스웜의 서비스로 생성된 컨테이너를 확인할 수 있으며, docker ps 명령어에 --filter is-task=true
        를 추가하면 스웜 모드의 서비스에서 생성된 컨테이너만 출력할 수 있다. 각 컨테이너의 이름은 서비스의 이름과 레플리카 번호, 자동으로 생성된 고유한
        ID를 조합해서 설정된다. 
        
            'docker ps --filter is-task=true --format {{.Names}}'
    }
    
    docker service ps 명령어를 통해 컨테이너 목록을 확인하면 새로운 컨테이너가 생성됐음을 확인할 수 있다. 특정 노드가 다운됐을 때도 위와 같은 방식으로
    동작한다. 
    
        'service docker stop'
        
    매니저 노드에서 docker node ls 명령어를 입력하면 worker1 노드가 Down으로 바뀐 것을 알 수 있다.  docker service ps 명령어로 다시 컨테이너
    의 목록을 확인해보면 swarm-worker1에서 구동 중이던 컨테이너가 종료됐으며, 이를 복구하기 위한 컨테이너가 swarm-manager 노드에 생성됐음을
    확인할 수 있다. 
    
    다운됐던 노드를 다시 시작해 정상적인 상태를 회복해도 장애를 복구하기 위해 다른 노드로 옮겨진 컨테이너가 해당 노드에 자동으로 할당되지는 않는다.
    즉, 다운됐던 도커 엔진을 다시 시작해 컨테이너를 실행할 수 있는 환경을 복구해도 해당 컨테이너가 다시 이전의 노드로 돌아가는 재균형(rebalance) 작업은
    일어나지 않는다는 뜻이다. 새로운 노드를 추가하거나 다운됐던 노드를 다시 복구했을 때 컨테이너 할당의 균형을 맞추기 위해서는 'scale' 명령어를 사용해서
    컨테이너 수를 줄이고 다시 늘려야한다.
        
        'docker service scale myweb=1'
        'docker service scale myweb=4'
```
#### 3.3.3.4 서비스 롤링 업데이트
```dockerfile
    스웜 모드는 롤링 업데이트를 자체적으로 지원하며, 매우 간단하게 사용할 수 있다. 매우 간단하게 사용할 수 있다. 우선 롤링 업데이트를 테스트 하기 위한
    서비스를 생성한다. 이 서비스는 앞에서 생성한 서비스와 유사하지만 이번에는 컨테이너 생성에 사용될 이미지를 nginx:1.10로 설정했다. 
    
        'docker service create --name myweb2 \
        --replicas 3 \
        nginx:1.10'
        
    서비스가 정상적으로 생성되면 docker service update 명령어로 서비스의 이미지를 업데이트할 수 있다. docker service update 명령어를 사용하면
    생성된 서비스의 각종 설정을 변경할 수 있다. 이미지를 업데이트하려면 update 명령어의 '--image' 옵션을 설정하면 됩니다. 다음 명령은 myweb2 서비스
    의 이미지를 nginx:1.11로 업데이트 한다.
    
        'docker service update \
        --image nginx:1.11 \ 
        myweb2'
        
    서비스 내의 컨테이너 목록을 확인하면 각 컨테이너의 이미지가 변경된 것을 알 수 있다. nginx:1.11 이미지와 nginx:1.10은 이미지 레이어의 차이가 
    크지 않으므로 빠른 속도로 롤링 업데이트가 진행된다. 아래 명령어의 출력 결과 중 NAME 항목이 \_ myweb2.1인 컨테이너가 롤링 업데이트의 대상이 되어 
    삭제된 컨테이너이며, \_가 붙어잇지 않은 컨테이너가 롤링 업데이트로 새롭게 생성된 컨테이너 이다. 
    
    {
        docker service ps 명령어에서 NAME 항목에 \_가 붙어있는 컨테이너는 어떠한 이유든 동작을 멈춘 컨테이너로서 서비스에서
        컨테이너 변경 기록을 나타낸다.
    }
    
    서비서를 생성할 떄 롤링 업데이트의 주기, 업데이트를 동시에 진행할 컨테이너를 개수, 업데이트에 실패했을 때 어떻게 할 것인지를 설정할 수 있다. 
    다음의 예는 컨테이너 레플리카를 10초 단위로 업데이트하며 업데이트 작업을 한 번에 2개의 컨테이너에 수행하는 것을 의미한다. 이를 설정하지 않으면
    주기 없이 차례로 컨테이너를 한 개씩 업데이트 한다.
    
        'docker service create \
        --replicas 4 \
        --name myweb3 \
        --update-delay 10s \
        --update-parallelism 2 \
        nginx:1.10'
    
    위와 같은 서비스의 롤링 업데이트 설정은 docker service inspect 또는 docker inpsect --type service 명령어로 확인할 수 있다.
    이 명령어는 롤링 업데이트 설정뿐 아니라 서비스 자체의 정보도 출력한다.
        
        'docker service inspect --pretty myweb3'
        
    내용 중 'On failure' 항목이 pause로 되어 있다면 이는 업데이트 도중 오류 발생시 롤링 업데이트를 중지하는 것을 의미한다. 
    업데이트 실패에 대해 아무런 설정도 하지 않으면 On failure 항목은 pause로 설정 되지만 서비스를 생성할 때 --update-failure-action 인자의 값을
    continue로 지정해 업데이트 중 오류가 발생해도 계속 롤링 업데이트를 진행하게 할 수 있다.
    
        'docker servie create --name myweb4 \
        --replicas 4 \
        --update-failrue-action continue \
        nginx:1.10'
    
    이러한 롤링 업데이트 옵션은 기본적으로 서비스 자체에 설정돼 있지만, 'docker service update' 명령어의 옵션 값을 다르게 설정함으로써 변경할 수
    있다. 서비스 롤링 업데이트 후, 서비스를 롱링 업데이트 전으로 되돌리는 롤백 또한 가능하다.
    
        'docker service rollback myweb3'
```

#### 3.3.3.5 서비스 컨테이너 설정 정보 전달하기 : config, secret
```dockerfile
    애플리케이션을 외부에 서비스하려면 각 환경에 맞춘 설정 파일이나 값들이 컨테이너 내부에 미리 준비되어 있어야 한다. 설정값을 이미지 내부에 정적으로 
    저장한 뒤 컨테이너로서 실행하도록 배포할 수도 있겠지만, 이미지에 내장된 설정값을 쉽게 변경할 수 없기 때문에 확장성과 유연성이 떨어지게 될 것이다. 
    지금까지 사용해 왔던 예제에서는 이를 해결하기 위해서 docker run 명령어의 -v 옵션을 통해 호스트에 위치한 설정 파일이나 값을 볼륨으로써 컨테이너에 
    공유했다. 
    
        'docker run -d --name yml_registry \
        -p 5002:5000 \
        --restart=always \
        -v $(pwd)/config.yml:/etc/docker/registry/config.yml \
        registry:2.6'

    또는 컨테이너 내부의 설정값을 유동적으로 설정하기 위해 -e 옵션을 통한 환경 변수도 사용할 수 있다.
    
        'docker run -d
        --name wordpressDB_hostvolume \
        -e MYSQL_ROOT_PASSWORD=password \
        -e MYSQL_DATABASE=wordpress \
        -v /home/wordpress_db:/var/lib/mysql \
        mysql:5.7'
        
    그러나 스웜 모드와 같은 서버 클러스터에서 파일 공유를 위해 설정 파일을 호스트마다 마련해두는 것은 매우 비효율적인 일이다. 그뿐만 아니라 비밀번호와 같이
    민감한 정보를 환경 변수로 설정하는 것은 보안상으로 매우 바람직하지 않기 때문에 이러한 습관은 지양하는 것이 좋다. 
    
    이를 위해 스웜 모드는 sercret과 config라는 기능을 제공한다. secret은 비밀번호나 SSH 키, 인증서 키와 같이 보안에 민감한 데이터를 전송하기 위해서,
    config는 nginx나 레지스트리 설정 파일과 암호화할 필요가 없는 설정값들에 대해 쓰일 수 있다. 
    
    그러나 secret과 config는 스웜 모드에서만 사용될 수 있는 기능이며, docker run 명령어에서는 사용할 수 없다. MYSQL과 같이 일반적으로 사용하는
    컨테이너들은 스웜 모드에서도 동일하게 사용할 수 있기 떄문에 secret, config 기능을 활용하고 싶으면 스웜 모드를 사용하는 것이 좋다.  
        
    
    1. secret 사용하기
    secret을 생성하려면 'docker secret create' 명령어를 입력한다. 아래 예시는 my_mysql_password라는 이름의 secret에 qwer1234라는 
    값을 저장한다. 파일의 내용을 터미널에 출력해 이를 secret으로 가져올 수도 있지만, 지금은 echo 명령어를 통해 값을 입력했다.
    
        'echo qwer1234 | docker secret create my_mysql_password -'
        
        'docker secret ls'
        
        'docker secret inspect my_mysql_password'
    
    그러나 생성된 secret을 조회해도 실제 값을 확인할 수는 없다. secret 값은 매니저 노드 간에 암호화된 상태로 저장된다. 이러한 secret 파일은 
    컨테이너에 배포된 뒤에도 파일 시스템이 아닌 메로리에 저장되기 때문에 서비스 컨테이너가 삭제될 경우 secret도 함께 삭제되는, 일종의 휘발성을
    띠게 된다. 
    
    생성한 secret을 통해 MYSQL 컨테이너를 하면 docker run 명령어로 했던 것과는 비슷하지만, --secret 옵션을 통해서 mysql 사용자 비밀번호를
    컨테이너 내부에 마운트 했다. source에 secret의 이름을 입력하고, target에는 컨테이너 내부에서 보여질 secret의 이름을 입력한다.
    
        'docker service create \
        --name mysql \
        --replicas 1 \
        --secret source=my_mysql_password, target=mysql_root_password \
        --secret source=my_mysql_password, target=mysql_password \
        -e MYSQL_ROOT_PASSWO_FILE="/run/secrets/mysql_root_password" \
        -e MYSQL_PASSWORD_FILE="/run/secrets/mysql_password" \
        -e MYSQL_DATABASE="wordpress" \
        mysql:5.7'
        
    --secret 옵션을 통해 컨테이너로 공유된 값은 기본적으로 컨테이너 내부의 /run/secret 디렉토리에 마운트된다. 
    
    {
        target의 값에 절대경로를 입력해서 다른 경로에 있는 secret 파일을 공유할 수도 있다. 
        docker service create \
        --secret source=my_mysql_password, target=/home/mysql_root_password \
        ...
    }
        
    그러나 이러한 방식의 값 전달에는 한 가지 고려할 점이 있다. 바로 컨테이너 내부의 애플리케이션이 특정 경로의 파일 값을 참조할 수 있도록 설계해야 한다.
    위의 예시는 Mysql 컨테이너가 -e MYSQL_PASSWORD_FILE="/run/secrets/mysql_password"와 같은 옵션을 통해서 특정 경로의 파일로부터 
    비밀번호를 로드할 수 있게 되어있다. 이처럼 애플리케이션을 개발할 때 각종 설정 변수를 파일로부터 동적으로 읽어올 수 있도록 설계하면 secret, config의
    장점을 활용할 수 있다.  
    
    
    2. config 사용하기
    config를 사용하는 방법은 secret과 거의 동일하다. 아래 명령어는 사설 레지스트리 개설 때 사용했던 레지스트리의 설정 파일을 registry-config라는
    이름의 config로 저장한다.
        'docker config create registry-config config.yml'
    
        'docker config ls'
        
        'docker config inspect registry-config' 
        
    'secret'과 달리 이번에는 Data라는 항목이 존재하는 것을 알 수 있다. config는 입력된 값을 base64로 인코딩 한 뒤 저장하며, base64 명령어를 
    통해서 디코딩하면 원래의 값을 확인할 수 있다. config의 내용은 사설레지스트리의 설정 내용을 변경했을 때 사용했던 파일이다. 
    
    config를 사용하는 방법은 'docker service create' 명령어에 --config 옵션을 추가하되, 사용법은 secret과 동일하다.
        
        'docker service create --name yml_registry -p 5000:5000 \
        --config source=registry-config, target=/etc/docker/registry/config.yml \
        registry:2.6'
        
    secret과 config의 값을 수정할 수 없지만, 서비스 컨테이너가 새로운 값을 사용해야한다면 docker service update 명령어의 --config-rm,
    --config-add, --secret-rm, --secret-add 옵션을 사용해서 사용하는 secret이나 config를 추가하고 삭제할 수 있다. 이를 잘 활요하면
    이미지를 다시 빌드할 필요 없이도 여러 설정값을 애플리케이션을 쉽게 사용할 수 있다.
```
#### 3.3.3.6 도커 스웜 네트워크
```dockerfile
    스웜 모드는 기존에 도커로 네트워크 사용하는 네트워크 구조와 조금 다른 방법을 사용한다. 스웜 모드는 여러 개의 도커 엔진에 같은 컨테이너를 분산해서
    할당하기 떄문에 각 도커 데몬의 네트워크가 하나로 묶인, 이른바 네트워크 풀이 필요하다. 이뿡만 아니라 서비스를 외부로 노출했을 때 어느 노드로 접근하더라도
    해당 서비스의 컨테이너에 접근할 수 있게 라우팅 기능이 필요하다. 이러한 네트워크 기능은 스웜 모드가 자체적으로 지원하는 네트워크 드라이버를 통해 사용할 수 
    있다. 
    
        'docker network ls'
        
    이전에 살펴봤던 bridge, host, none 네트워크 외에도 docker_gwbridge와 ingress 네트워크가 생성된 것을 알 수 있다. docker_gwbrdige 
    네트워크는 스웜에서 오버레이(overlay) 네트워크를 사용할 떄 사용되며, ingress 네트워크는 로드 밸런싱과 라우팅 메시(Routing Mesh)에 사용된다.
    
    
    1. ingress 네트워크 
    ingress 네트워크는 스웜 클러스터를 생성하면 자동으로 등록되는 네트워크로서, 스웜 모드를 사용할 때만 유효하다. 이는 docker network ls 명령어를
    입력했을 때 확인할 수 있는 SCOPE 항목에서 swarm으로 설정된 것에서 알 수 있다. 매니저 노드뿐 아니라 스웜 클러스터에 등록된 노드라면 전부
    ingress 네트워크가 생성된다. 
    
        'docker network ls | grep ingress'
        
    
        192.168.99.100:80               192.168.99.101:80               192.168.99.102:80
                |                               |                               |
                |                               |                               |
                ↓                               ↓                               ↓
        -----------------------------------------------------------------------------------
                                          ingress 네트워크
        -----------------------------------------------------------------------------------
             로드 밸런서                         로드 밸런서                      로드 밸런서
             
          swarm-manager                     swarm-worker1                   swarm-worker2
          
    
    ingress 네트워크를 사용하는 서비스의 구조는 위와 같다. ingress 네트워크는 어떤 스웜 노드에 접근하더라도 서비스 내의 컨테이너에 접근할 수 있게
    설정하는 라우팅 메시를 구성하고, 서비스 내의 컨테이너에서 대한 접근을 라운드 로빈으로 로드 밸런싱을 담당한다. 이는 이전에 노드가 몇 개가 있는지와 
    관계 없이 어떠한 노드로도 접근이 가능했던 것과 같다. 
    
    그렇지만 스웜 모드로 생성된 모든 서비스의 컨테이너가 외부로 노출되기 위해 무조건 ingress 네트워크를 사용해야하는 것은 아니다. docker run -p를
    사용해서 외부에 컨테이너를 노출했던 것처럼 호스트의 특정 포트를 사용하도록 설정할 수 있다. ingress  네트워크를 사용하지 않고 호스트의 8080번 
    포트를 직접 컨테이너의 80번 포트에 연결하는 예시이다.
    
        'docker service create \
        --publish mode=host, target=80, published=8080, protocol=tcp \
        --name web
        nginx'
        
    그러나 ingress 네트워크를 사용하지 않고 위와 같이 서비스를 외부로 노출할 경우 어느 호스트에서 컨테이너가 생성될지 알 수 없어 포트 및 서비스 관리가
    어렵다는 단점이 있다. 따라서 가급적이면 ingress 네트워크를 사용해서 외부로 서비스를 노출하는 것이 좋다. 
        
    
    2. 오버레이 네트워크 
    그렇다면 스웜 클러스터 내의 컨테이너가 할당받는 IP주소는 어떻게 설정돼 있을까?
    
```

