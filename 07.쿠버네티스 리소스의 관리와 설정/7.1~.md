###7 쿠버네티스 리소스의 관리와 설정
```dockerfile
    지금까지 본 포드, 레플리카셋, 디플로이먼트, 서비스는 쿠버네티스 애플리케이션을 배포하기 위해서 반드시 있어야하는 필수요소이다. 이 외에도 kubectl api-
    resource으로 볼 수 있듯이 훨씬 더 많은 오브젝트가 있다. 예를 들어 애플리케이션을 관리하기 위해 자주 사용되는 네임스페이스(Namespace), 컨피그맵
    (configMap), 시크릿(Secret) 등이 있다. 
```
####7.1 네임스페이스(Namespace) : 리소스를 논리적으로 구분하는 장벽
```dockerfile
    도커나 도커 스웜모드를 사용할 때는 컨테이너를 논리적으로 구분하는 방법이 없었다. docker run이나 docker-compose 명령어로 수백 개의 컨테이너를 
    생성했다고 하더라도 docker ps로 컨테이너 목록을 확인할 수 있었다. 그렇지만 용도에 따라 컨테이너와 그에 관련된 리소스들을 구분 지어 관리할 수 있는, 
    일종의 논리적인 그룹이 있다면 조금 더 관리에 용이할 것이다. 쿠버네티스는 리소스를 논리적으로 구분하기 위해서 네임스페이스라는 오브젝트를 제공한다.
    간단히 생각해서 네임스페이스는 포드, 레플리카셋, 디플로이먼트, 서비스 등과 같은 쿠버네티스 리소스들이 묶여 있는 하나의 가상 공간 또는 그룹이라고 
    이해하면 된다. 
    
    예를 들어 모니터링을 위한 모든 리소스들은 monitoring이라는 이름의 네임스페이스에서 생성할 수 있고, 테스트를 위한 리소스들은 testbed라는 네임스페이스
    에서 생성할 수 있다. 또는 여러 개발 조직이 하나의 쿠버네티스 클러스터를 공유해 사용해야 한다면 조직별로 네임스페이스를 사용하도록 구성할 수도 있다.
    이렇게 여러 개의 네임스페이스를 사용하면 마치 하나의 클러스터에서 여러 개의 가상 클러스터를 동시에 사용하는 느낌이 들 것이다.
    
    >  네임스페이스 기본 개념 이해
    
    네임스페이스는 namespace 또는 ns라는 이름으로 쿠버네티스에서 사용할 수 있으며, 네임스페이스의 목록은 'kubectl get namespaces' 명령어로 확인할 
    수 있다. 기본으로 3개의 네임스페이스가 존재한다. 각 네임스페이스는 논리적인 리소스 공간이기 때문에 각 네임스페이스에는 포드, 레플리카셋, 서비스와 같은
    리소스가 따로 존재한다. 예를 들어서 default라는 이름의 네임스페이스에 생성된 포드를 확인하려면 'kubectl' 명령어에 '--namespace' 옵션을 사용하면
    된다. 'kubectl get pods --namesapce default'
    default는 쿠버네티스를 설치하면 자동으로 사용하도록 설정되는 네임스페이스로, kubectl 명령어로 쿠버네티스 리소스를 사용할 때는 기본적으로 default
    네임스페이스를 사용한다. 즉, '--namespace' 옵션을 명시하지 않으면 기본적으로 default 네임스페이스를 사용한다.
    
    'kube get pods -n kube-system' (--namespace 대신 -n 가능)으로 쿠버네티스 초기 네임스페이스를 확인해보면 우리가 생성한 적 없는 포드가 여러
    개 실행되고 있다.  'kube-system' 네임스페이스는 쿠버네티스 클러스터 구성에 필수적인 컴포넌트들과 설정 값이 존재하는 네임스페이스이다. 물론 서비스, 
    레플리카셋을 비롯한 여러 리소스들도 각 네임스페이스에 존재한다. 예를 들어, kube-system 네임스페이스에는 쿠버테티스의 포드, 서비스 등을 이름으로 찾을
    수 있도록 하는 DNS 서버의 서비스가 미리 생성돼 있다.  
 
    이처럼 네임스페이스는 쿠버네티스의 리소스를 논리적으로 묶을 수 있는 가상 클러스터처럼 사용할 수 있다. 쿠버네티스 클러스터를 여러 명이서 동시에 사용해야
    한다면 사용자마다 네임스페이스를 별도로 생성해서 사용하도록 설정할 수도 있다. 또는 용도에 따라 네임스페이스를 여러 개 만듦으로써 특정 목적의 디플로이면트,
    서비스 들은 특정 네임스페이스에서만 존재하도록 만들 수도 있다. 네임스페이스는 대부분 모니터링, 로드 밸런싱 인그레스(Ingress) 등의 특정 목적을 위한
    용도가 대부분일 것이다. 
    
    그렇지만 각 네임스페이스의 리소스들은 논리적으로만 구분된 것일 뿐, 물리적으로 격리된 것이 아니다. 예를 들어 서로 다른 네임스페이스에서 생성된 포드가 
    같은 노드에 존재할 수도 있다. 그렇다면 네임스페이스와 라벨의 차이점은 무엇인가? 이전에 서비스와 포드를 매칭시키기 위해서 사용했던 라벨 또한 리소스를
    분류하고 구분하기 위한 방법이었다. 예를 들어 app=webServer라는 라벨을 가지는 포드만 출력하려면 '-l' 옵션을 사용할 수 있다. 
    'kubectl get pods -l app=webserver' 명령어로 이를 수행 할 수 있다.
    
    네임스페이스는 라벨보다 더욱 넓은 용도로 사용할 수 있다. 예를 들어 ResourceQuota 라는 오브젝트를 이용해서 특정 네임스페이스에서 생성되는 포드의 자원
    사용량을 제한한다거나, 애드미션 컨트롤러라는 기능을 이용해서 특정 네임스페이스에 생성되는 포드에는 항상 사이드카 컨테이너를 붙이도록 설정할 수 있다. 
    무엇보다도 쿠버네티스에서 사용 목적에 따라 포드, 서비스 등의 리소스를 격리함으로써 편리하게 구분할 수 있다는 특징도 있다. 
    {
        여기서의 네임스페이스는 리눅스 네임스페이스와는 다르다. 리눅스 네임스페이스는 컨테이너의 격리된 공간을 생성하기 위해 리눅스 커널 자체 기능을 활용
        하는 것이며, 일반적으로 네트워크나 마운ㅌ, 프로세스 네임스페이스 등을 의미한다.
    }
    
    > 네임스페이스 사용하기
    
    네임스페이스는 지금까지 사용했던 방식처럼 YAML 파일에 정의해서 생성할 수 있다.
```
```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: production
```
```dockerfile
    위 yaml은 'kubectl apply -f production-namesapce.yaml'으로 실행 시킬 수 있고 'kubectl create namespace' 명령어로도 실행 시킬 수 
    있다. 또는 'kubectl create namespace production' 명령어로도 실행시킬 수 있다. 추가적으로 특정 네임스페이스에 리소스를 생성하는 방법은 아래와
    같다.
```
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hostname-deployment-ns
  namespace: production
spec:
  .....
---

apiVersion: v1
kind: Service
metadata:
  name: hostname-svc-clusterip-ns
  namespace: production
spec
  .....
```
```dockerfile
    {
        하나의 YAML 파일에 ---를 명시해 여러 개의 리소스를 정의할 수 있다. 위의 YAML을 보면 ---으로 디플로이먼트와 서비스를 동시에 정의했으며,
        kubectl apply -f를 사용할 경우 디플로이먼트와 서비스가 동시에 생성된다. 
    }
    
    
    
    > 네임스페이스의 서비스에 접근하기
    
    이전에 서비스 오브젝트를 설명할 때, 쿠버네티스 클러스터 내부에서는 서비스 이름을 통해 포드에 접근할 수 있다고 알고 있다. 이는 정확히 표현하면
    '같은 네임스페이스 내의 서비스'에 접근할 때에는 서비스 이름만으로 접근할 수 있다는 뜻이다.
    그렇지만 다른 네임스페이스에 존재하는 서비스에는 서비스 이름만으로 접근할 수 없다. 예를 들어 'default' 네임스페이스에서 'production' 이라는 
    네임스페이스의 서비스에 접근하지 못한다는 것을 의미한다. 하지만 <서비스이름>.<네임스페이스 이름>.svc처럼 서비스 이름 뒤에 네임스페이스 이름을 붙이면
    다른 네임스페이스의 서비스에도 접근할 수 있다. 예를 들어 default에서 production 네임스페이스에 있는 hostname-svc-cluster-ns라느 서비스에는
    다음과 같이 접근할 수 있다.
    'curl hostname-svc-clusterip-ns.production.svc:8080 --slient | grep Hello'
    {
        서비스의 DNS 이름에 대한 FQDN(Full Qualifed Domain Name)은 일반적으로 아래 다음과 같은 형식으로 구성되어 있다.
        <서비스 이름>.<네임스페이스 이름>.svc.cluster.local
    }
    
    네임스페이스는 kubectl delete -f <YAML 파일명> 또는 kubectl delete namespace 명령어로 삭제할 수 있다. 단, 네임스페이스에 존재하는 
    모든 리소스 또한 함께 삭제되기 떄문에 네임스페이스를 삭제하기 전에 리소스를 확인하는 것이 좋다.
    
    
    
    > 네임스페이스에 종속되는 쿠버네티스 오브젝트와 독립적인 오브젝트
    
    네임스페이스를 사용하면 쿠버네티스 리소스를 사용 목적에 따라 논리적으로 격리할 수 있지만, 모든 리소스가 네임스페이스에 의해 구부노디는 것은 아니다. 
    앞서 익힌 포드, 서비스, 레플리가셋, 디플로이먼트는 네임스페이스 단위로 구분할 수 있다. 예를 들어 A라는 네임스페이스에서 포드를 만들면 A 네임스페이스에서
    만 보이고, B네임스페에스에서는 보이지 않는다. 이런 경우를 쿠버네티스에서는 '오브젝트가 네임스페이스에 속한다(namesapced)'라고 표현한다. 네임스페이스에
    속하는 오브젝트의 종류는 'kubectl api-resources --namespace=true'로 확인할 수 있다.  
    
    이와 반대로 네임스페이스에 속하지 않는 쿠버네티스 오브젝트도 있다. 이전에 사용했던 명령어 중에서 클러스터의 노드들을 확인하기 위해 kubectl get nodes
    명령어를 사용하면 된다. 노드(nodes) 또한 쿠버네티스의 오브젝트 중 하나지만, 네임스페이스에 속하지 않는 대표적인 오브젝트 중 하나다. 따라서 'kubectl\
    get nodes' 명령어에 --namespace 옵션을 추가해도 의미가 없다. nodes는 쿠버네티스 클러스터에서 사용되는 저수준의 오브젝트이며, 네임스페이스에
    의해 구분되지 않기 때문이다. 노드처럼 네임스페이스에 속하지 않는 오브젝트들은 보통 네임스페이스에서 관리되지 않아야하는 클러스터 전반에 걸쳐 사용되는 
    경우가 많다. 네임스페이스에 속하지 않는 오브젝트의 종류는 'kubectl api-resources --namespaced=false'로 확인할 수 있다. 
    또한 노드는 물론 네임스페이스 자체도 네임스페이스에 종속되지 않는다는 것을 알 수 있다. 
```

#### 7.2 컨피그맵(Configmap), 시크릿(Secret) : 설정값을 포드에 전달
```dockerfile
    애플리케이션은 대부분 설정 값을 가지고 있다. 예를 들어 키-값과 같은 형태의 설정을 사용할 수도 있고, Nginx 웹 서버가 사용하는 nginx.conf 처럼
    완전한 하나의 파일을 사용해야 할 수도 있다.  이러한 설정 값이나 설정 파일을 애플리케이션에 전달하는 가장 확실한 방법은 도커 이미지 내부에 설정 값 또는
    설정 파일을 정적으로 저장해 놓는 거싱다. 하지만 도커 이미지는 일반 빌드되고 나면 불변의 상태가 되기 떄문에 이 방법은 상황에 따라 설정 옵션을 유연하게
    변경할 수 없다는 단점이 있다. 
    이에 대한 대안으로 포드를 정의하는 YAML 파일에 환경 변수를 직접 적어 놓는 방식을 사용할 수 있다. 예를 들어 디플로이 먼트의 YAML 파일 중 포드
    템플릿에서 직접 환경 변수를 적용하는 방식이다.
```
```yaml
spec:
  containers:
    - name: LOG_LEVEL
      value: INFO
    image: nginx:1.10
```
```dockerfile
    위처럼 환경 변수를 포드 템플릿에 직접 명시하는 방식도 나쁘지 않지만, 상황에 따라서는 환경 변수의 값만 다른, 동일한 여러 개의 YAML이 존재할 수도 있다. 
    만약 운영 환경과 개발 환경에서 각각 디플로이먼트를 생성해야 한다면 환경 변수가 서로 다르게 설정된 두 가지 YAML 파일이 따로 조재해야 하기 때문이다.
    
    쿠버네티스는 YAML 파일과 설정 값을 분리할 수 있는 컨피그맵(Configmap)과 시크릿(Secret)이라는 오브젝트를 제공한다. 컨피그맵에는 설정값을, 시크릿에는
    노출되어서는 안 되는 비밀 값을 저장할 수 있다. 1개의 포드 YAML 파일만을 사용하면 굳이 컨피그맵을 사용할 필요가 없을 수 있으며 그 이상의 개수를 사용한
    다면 환경 변수나 설정 값까지 쿠버네티스 오브젝트에서 관리할 수 있다. 따라서 컨피그맵이나 시크릿을 사용하면 애플리케이션과 설정 값을 별도로 분리해서 관리할 
    수있다는 장점이 있다.
    {
        쿠버네티스의 컨피그맵과 시크릿은 이전 장에서 사용했던 도커 스웜 모드의 config, secret의 개념과 매우 비슷하다. 이처럼 도커 스웜 모드와 쿠버네티스
        는 서로 비슷한 기능이 많지만 세부 기능을 더 폭넓게 제공하고 있어 쿠버네티스 수요가 높다. 
    }
```

#### 7.2.1 컨피그맵(Configmap)
```dockerfile
    > 컨피그맵 사용 방법 익히기 
    
    컨피그맵은 일반적인 설정값을 담아 저장할 수 있는 쿠버네티스 오브젝트이며, 네임스페이스에 속하기 때문에 네임스페이스별로 컨피그맵이 존재한다. 컨피그맵을
    생성하는 방법에는 YAML로 생성하는 방법도 있지만, 'kubectl create configmap' 명령어를 사용해도 컨피맵을 생성할 수 있다. 예를 들어서 'kubectl\
    create configmap log-level-configmap --from-literal LOG_LEVEL=DEBUG'로 LOG_LEVEL_DEBUG라는 키, DEBUG라는 값을 가진 컨피그맵을
    만들 수 있다. 또는 '--from-literal' 옵션을 여러 번 사용함으로써 여러 개의 키-값을 컨피그맵에서 사용하도록 설정할 수도 있다. 'kubectl create \
    configmap start-k8s --from-literal k8s=kubernetse --from-literal container=docker'와 같이 start-k8s라는 컨피그맵에 두 개의
    키-값 쌍을 저장할 수도 있다. 컨피그맵에 저장된 설정값은 'kubectl describe configmap' 명령어나 kubectl get configmap -o yaml 명령어로
    확인할 수 있다. 
    
    컨피그맵을 생성했다면 그 다음은 컨피그맵의 값을 포드로 가져와 볼 차례이다. 생성된 컨피그맵을 포드에서 사용하려면 디플로이먼트 등의  YAML 파일에서 
    포드 템플릿 항목에 컨피그맵을 사용하도록 정의하면 된다. 컨피그맵을 포드에서 사용하는 방법은 크게 두 가지가 있다. 
    
    1. 컨피그맵을 값을 컨테이너의 환경 변수로 사용하는 방법
        컨피그맵의 값을 포드의 컨테이너 환경 변수로 가져온다. 컨피그맵에 저장된 키-값 데이터가 커테이너의 환경 변수의 키-값으로서 그대로 사용되기 때문에
        셸에서 echo $LOG_LEVEL과 같은 방식으로도 값을 확인할 수 있다.
    
    2. 컨피그맵의 값을 포드 내부의 파일로 마운트해서 사용
        컨피그맵의 값을 포드 컨테이너 내부의 특정 파일로 마운트한다. 예를 들어 LOG_LEVEL=INFO라는 값을 가지는 컨피그맵을 /etc/config/log_level이
        라는 파일로 마운트하면 log_level 파일에는 INFO라는 값이 저장된다. 이때 파일이 위치할 경로는 별도로 설정할 수 있다. nginx.conf 등의 파일을
        통해서 설정 값을 읽어들인다면 사용할 만한 방법이다. 
        
        
    > 컨피그맵의 데이터를 컨테이너의 환경 변수로 가져오기 
    컨피그맵의 값을 환경 변수로 사용해서 포드를 생성하려면 
```
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: container-env-example
spec:
  containers:
    - name: my-container
      image: busybox
      args: ['tail', '-f', '/dev/null']
      envFrom:
      - configMapRef:
         name: log-level-configmap
      - configMapRef:
        name: start-k8s
```
```dockerfile
    위의 YAML을 사용하면 된다. 그 중에서 중요한 부분은 envFrom, configMapRef이다. envFrom 항목은 하나의 컨피그 맵에 여러 키-값 쌍이 존재하더라도
    모두 환경 변수로 가져오도록 설정한다. 그래서 컨피그맵에 두 개 이상의 키-값이 있는 것을 한꺼번에 가져와서 포드에 등록 시킬 수 있다.  포드를 생성한 뒤
    포드 내부에서 환경 변수의 목록을 출력해보려면 env를 환경 변수를 출력할 수 있다.  
```