## 8.0 쿠버네티스 고급 기능

```text
    실제 운영 환경에서 쿠버네티스를 사용하려면 훨씬 많은 기능이 필요하다. 예를 들어 네트워크 7계층에서 가상 호스트를 이용해 서비스 요청을 
    처리하거나, 애플리케이션의 영속적인 데이터를 보관하기 위한 외부 볼륨이 필요할 수도 있다. 또한 여러 명의 개발자 또는 애플리케이션이 
    함께 사용하는 쿠버네티스 클러스터에서는 보안을 위해 반드시 권한을 관리해야 하며, 특정 포드가 컴퓨팅 자원을 독차지하는 것을 막기 위해
    메모리, CPU 사용량의 제한을 위한 체계적인 시스템도 필요할 것이다.
    
    다행히도 쿠버네티스는 이러한 고급 기능들을 자체적으로 제공하고 있으며, 다른 솔루션 또는 플랫폼과 쉽게 연동해 사용할 수 있다. 따라서 이러한
    쿠버네티스 고급 기능의 사용방법을 숙지하고 쿠버네티스 클러스터에 적용하기만 하면 되므로 직접 고급 기능을 구현하는 수고를 덜 수 있다. 
    
    단, 쿠버네티스의 기능은 매우 방대하기 때문에 관리해야 할 포인트가 늘어나게 된다는 단점도 있다. 고급 기능의 사용방법을 제대로 이해해야만
    실제 환경에 적용할 수 있으며, 서드 파티 도구를 연동하려면 클라우드 뿐만아니라 네트웤, 스토리지 등의 다양한 지식이 필요하다. 이런 부분에서
    얽히고 얽혀서 쿠버네티스 자체의 관리가 어려울 수 있다.라는 평이 있는 것이다.
    
    반대로 이를 이해하면 본인의 애플리케이션에 맞는 환경을 효율적으로, 세밀하게 구성할 수 있다. 
```
### 8.1 인그레스(Ingress)
```text
    인그레스(Ingress)는 일반적으로 외부에서 내부로 향하는 것을 지칭하는 단어이다. 예를 들어 인그레스 트래픽은 외부에서 서버로 유입되는 트래픽
    을 의미하며, 인그레스 네트워크는 인그레스 트래픽을 처리하기 위한 네트워크를 의미한다.
    
    이전에 사용해봤던 서비스 오브젝트가 외부 요청을 받아들이기 위한 것이었다면 '인그레스'는 외부 요청을 어떻게 처리할 것인지 네트워크 7계층
    레벨에서 정의하는 쿠버네티스 오브젝트이다. 여기서 '처리한다.'는 문장에는 많은 기능이 내포돼 있는데, 인그레스 오브젝트가 담당할 수 있는 
    기본적인 기능만 나열해보겠다.
    
        1. 외부 요청의 라우팅 : /hello 등과 같이 특정 경로로 들어온 요청을 어떠한 서비스로 전달할지 정의하는 라우팅 규칙을 설정할 수 있다.
        2. 가상 호스트 기반의 요청 처리: 같은 IP에 대해 다른 도메인 이름으로 요청이 도착했을 떄, 어떻게 처리할 것인지 정의할 수 있다.
        3. SSL/TLS 보안 연결 처리 : 여러 개의 서비스로 요청을 라우팅할 떄, 보안 연결을 위한 인증서를 쉽게 적용할 수 있다.
        
    하지만 인그레스의 기능이 위 기능에만 제한되는 것은 아니며, 인그레스를 어떻게 활용하느냐에 따라 다양한 기능을 사용할 수 있다.
    인그레스 자체의 기능은 비교적 정해져 있더라도 인그레스의 요청을 처리할 서버로 무엇을 선택하느냐에 따라 기능이 조금씩 달라지기 때문이다.
    
    > 인그레스를 사용하는 이유
    꼭 인그레스를 사용해야만 위의 기능을 구현할 수 있는 것은 아니다. NodePort, LoadBalancer 타입의 서비스를 사용해도 위 기능을 구현하는 
    것이 가능하기 때문이다. 그럼 인그레스는 왜 사용해야하는가?
    
    예를 들어서 애플리케이션이 3개인 디플로이먼트로 구성되어 있다고 가정해보자 지금까지 배운대로면 각 디플로이먼트를 외부로 노출해야한다면
    NodePort 또는 LoadBalancer 타입의 서비스 3개를 생성하는 방법이 떠오를 것이다. 각 디플로이먼트에 대응하는 서비스를 하나씩 연결해준 
    셈이다. 
    
    이러한 방식이 잘 동작할 것 같지만 서비스마다 세부적인 설정을 추가할 때 여러모로 복잡한 상황에 마주하게 될 것이다. SSL/TLS  보안 연결,
    접근 도메인 및 클라이언트 상태에 기반한 라우팅 등을 구현하려면 각 서비스와 디플로이먼트에 대해 일일이 설정을 해야하기 때문이다.
    물론 앞서 설명한대로 이러한 것들이 NodePort나 LoadBalancer 타입의 서비스로 불가능한 것은 아니지만, 쿠버네티스가 제공하는 인그레스 
    오브젝트를 사용하면 URL 엔드포인트를 단 하나만 생성함으로써 이러한 번거로움을 쉽게 해결할 수 있다. 3개의 디플로이먼트를 외부로 노출하는 
    인그래스를 생성하면 각각 총 3개의 URL이 존재하는 것이 아니라, 인그레스에 접근하기 위한 단 하나의 URL만 존재한다. 따라서 클라이언트는
    인그레스의 URL로만 접근하게 되며, 해당 요청은 인그레스에서 정의한 규칙에 따라 처리된 뒤 적절한 디플로이먼트의 포드로 전달된다.
    
    이 관점에서 중요한 점은 라우팅 정의나 보안 연결 등과 같은 세부 설정은 서비스와 디플로이먼트가 아닌 인그레스에 의해 수행된다는 것이다. 각
    디플로이먼트에 대해 일일이 설정을 적용할 필요 없이 하나의 설정 지점에서 처리 규칙을 정의하기만 하면 된다. 즉, 외부 요처엥 대한 처리 규칙
    을 쿠버네티스 자체 기능으로 편리하게 관리할 수 있다는 것이 인그레스의 핵심이다. 
    
```

#### 8.2 인그레스의 구조

```dockerfile
    인그레스는 쿠버네티스에서 ingress라는 이름으로 사용할 수 있으며, 'kubectl get ingress[ing]'명령어로 인그레스의 목록을 확인할 수 있다.
```
```yaml
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: ingress-example
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    kubernetes.io/ingress.class: "nginx"
spec:
  rules:
   - host: alicek106.example.com  #[1]
     http:
      paths:
      - path: /echo-hostname  #[2]
        backend:
          serviceName: hostname-service #[3]
          servicePort: 80
```
```dockerfile
      #1 -> 해당 도메인 이름으로 접근하는 요처엥 대해서 처리 규칙을 적용한다. 위 예시는 alicek~.com이라는 도메인으로 접근하는 요청만 처리
      #한다. 단, 여러 개의 host를 정의해서 사용할 수도 있다.
      #
      #2 -> 해당 경로에 들어온 요청을 어느 서비스로 전달할 것인지 정의한다. 위 예시에서는 /echo-hostname이라는 경로의 요청을 backend에
      #정의된 서비스로 전달한다. 여러 개의 path를 정의해서 경로를 처리할 수도 있다.
      #
      #3 -> path로 들어온 요청이 전달될 서비스와 포트이다. 즉, 위 예시에서는 /echo-hostname으로 들어온 요청을 hostname-service 서비스의
      #80번 포트로 전달한다. 
      
      {
            인그레스를 정의하는 YAML 파일 중에서 annotation 항목을 통해 인그레스의 추가적인 기능을 사용할 수 있으며, 위의 YAML 파일에서도
            두 가지의 주석을 사용했다. 
      }
    
    'kubectl apply -f ingress-example.yaml'로 인그레스를 생성한 다음 'kubectl get ingress'로 목록을 보면 ingress-example이라는
    이름으로 인그레스를 생성했지만, 이것만으로는 아무 일도 일어나지 않는다. 인그레스는 단지 요청을 처리하는 귲칙을 정의하는 선언적인 오브젝트
    일 뿐, 외부 요청을 받아들일 수 있는 '실제 서버가 아니다.'라는 것을 잊으면 안된다. 인그레스는 인그레스 컨트롤러(ingress-controller)
    라고 하는 특수한 서버에 적용해야만 그 규칙을 사용할 수 있다. 
```
