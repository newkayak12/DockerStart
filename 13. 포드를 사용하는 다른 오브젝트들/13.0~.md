```dockerfile
                > 포드를 사용하는 다른 오브젝트들
    
    포드를 사용하는 다른 상위 오브젝트에서는 포드의 기능을 그대로 사용할 수 있기 때문에 지금까지 쿠버네티스의 기능을 사용할 때는 대부분 포드 기준으로 보면 
    됐다. 오브젝트 내에서 포드를 사용할 경우 YAML 파일 등에서 포드 템플릿을 이용해 포드의 기능을 정의할 수 있기 때문이다. 대표적인 예시로 디플로이먼트에서
    포드를 사용했던 것을 떠올려보자. 디플로이먼트에서는 spec.template 항목을 통해 사용할 포드의 기능을 정의했다. 
    ...
        matchLabels:
            app: webserver
        template:
            metadata:
                name: my-webserver
                labels:
                    app: webserver
        spec:
            containers:
            - name: my-webserver
              image: alicek106/rr-test:echo-hostname
              ports:
              - cotainerPort: 80
              
      ==> 디플로이먼트에서 포드를 정의하는 템플릿 
  
    이처럼 포드를 사용하는 상위 오브젝트에는 디플로이먼트 외에도 몇 가지가 더 있다. 
    
    
    
            > 1. 잡(Jobs)
    잡(Job)은 특정 동작을 수행하고 종료해야하는 작업을 위한 오브젝트이다. 포드를 생성해 원하는 동적을 수행한다는 점에서는 디플로이먼트와 같지만, 잡에서 
    원하는 최종 상태는 '특정 개수의 포드가 실행 중인 것'이 아닌 '포드가 실행되어 정상적으로 종료되는 것'이라는 점에서 차이가 있다. 따라서 잡에서 포드의
    컨테이너가 종료 코드로서 0을 반환해 Completed 상태가 되는 것을 목표로 한다. 
    
    예를 들어, 포드에서 Hello, World만을 출력하고 종료되는 간단한 잡을 생성해보자. 
```
job-hello-world.yaml
```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: job-hello-world
spec:
  template:
    spec: 
      restartPolicy: Never
      containers:
      - image: busybox
        args: ['sh', '-c' 'echo hello, world && exit 0']
        name: job-hello-world
```
```dockerfile
    kind가 Job으로 설정됐다는 점을 제외하면 위의 YAML 파일은 단일 포드를 정의하는 YAML 파일과 다른 점은 거의 없어 보인다. 단, 앞서 설명한 것처럼
    잡의 포드가 최종적으로 도달해야하는 상태는 Running이 아니라 completed이기 때문에 포드의 restartPolicy를 명시적으로 Never 또는 OnFailure로
    지정해 줘야 한다.
    위 YAML로 잡을 생성한 뒤, 잡과 포드의 목록을 확인해보자. 
    
            'kubectl apply -f job-hello-world.yaml'
            'kubectl get pods'
            'kubectl get jobs'
        
    생성된 포드는 Hello, world만 출력하고 종료되기 때문에 곧바로 Completed가 됐으며, 잡의 COMPLETIONS 항목에서는 1/1이라는 문구로 1개의 포드가 
    정상적으로 수행됐음을 나타내고 있다. 
    
    잡에서 생성된 포드는 항상 실행 중인 것을 목표로 하지 않기 때문에, 잡 오브젝트를 어디에서 사용해야 할지 의문이 들 수 있다. 사용자의 요청을 처리하는 서버와 
    같은 애플리케이션의 관점이 아닌, 한 번 수행하고 종료되는 배치(Batch) 작업을 위한 관점에서 생각해보면 잡의 쓰임새를 쉽게 이해할 수 있다. 프레임을 
    렌더링하거나 파일을 인코딩하는 작업처럼 데이터를 가공해야 하는 배치 워크로드를 쿠버네티스에서 수행해야 한다고 생각해보자. 이러한 배치 워크로드의 애플리케이션
    은 항상 실행 중일 필요가 없으며, 원하는 동작을 수행한 뒤 종료되기만 하면 그것만으로 충분하다. 이러한 상황에서는 디플로이먼트보다는 잡을 사용하면 배치
    워크로드를 조금 더 명확히 정의해 사용할 수 있다.
    
    단, 잡은 동시성을 엄격하게 보장해야 하는 병렬 처리를 위해 사용하는 것이 아니라는 점을 알아둬야 한다. 또한 잡의 실패하면 포드가 restartPolicy에 따라 
    재시작될 수도 있어서 잡이 처리하는 작업은 멱등성을 가지는 것이 좋다. 
    
        {
            쿠버네티스의 공식 문서에서는 YAML 템플릿을 이용해서 동일한 잡을 여러 개 생성하거나 Message Queue나 Redis에 작업 큐를 저장해 준 뒤
            잡이 작업 큐를 꺼내와 처리하도록 하는 패턴 등을 설명하고 있다. 
        }
        
        
            > 잡의 세부 옵션
    위 예시에서는 잡에서 포드를 하나만 생성했으며, 포드가 한 번만에 설공했기 때문에 별도의 옵션을 설정할 필요가 없었다. 하지만 실제로 배치 워크로드에서 잡을
    사용하려면 다양한 옵션을 함께 사용해야만 효율적으로 잡업을 끝낼 수 있다. 잡에서 자주 사용되는 세부 옵션은 아래와 같다.
    
        - spec.completions: 잡이 성공했다고 여겨지려면 몇 개의 포드가 성공해야하는지 (정상적으로 종료돼야 하는지) 설정한다. 기본값은 1이다.
        - spec.parallelism: 동시에 생성될 포드의 개수를 설정한다. 기본값은 1이다.
        
    spec.completions는 해당 잡이 성공했다고 여겨지려면 포드가 총 몇 개 있어야하는지를 의미한다. 기본적으로 1로 설정돼 있어서 1개의 포드가 정상적으로
    종료되면 잡 또한 성공했다고 간주한다. 만약 3으로 설정한다면? 
```
job-completion.yaml
```yaml
    ... 
      name: job-completions
    spec: 
      completions: 3
      teamplate:
    ...
```
````dockerfile
        'kubectl apply -f job-completions.yaml'
        'kubectl get pods -w'
        
                NAME           READY       STATUS          RESTARTS    AGE 
        job-completions-7fs99   0/1   ContainerCreating        0        3s
        job-completions-7fs99   0/1      Completed             0        12s 
        job-completions-mv9d7   0/1      Pending               0        0s 
        job-completions-mv9d7   0/1      Pending               0        0s 
        job-completions-mv9d7   0/1   ContainerCreating        0        0s 
        job-completions-mv9d7   0/1      Completed             0        9s 
        job-completions-lx2sh   0/1      Pending               0        0s 
        job-completions-lx2sh   0/1      Pending               0        0s 
        job-completions-lx2sh   0/1   ContainerCreating        0        0s 
        job-completions-lx2sh   0/1      Completed             0        7s
        
        포드가 순차적으로 하나씩 생성됐고, 포드가 Completed 상태가 되자마자 바로 다음 포드가 실행됐다. job-completion이라는 잡의 입장에서는 3개의
        포드가 정상적으로 종료돼야만 잡이 성공적으로 수행된 것으로 간주하기 때문에 포드르 한 개씩 3번 생성한 것이다. 그리고 결국 3개의 포드가 하나씩 
        정상적으로 종료되어 completions의 횟수를 채웠기 때문에 잡은 최종적으로 성공한 것으로 여겨진다.
        
                'kubectl get job job-completions -o yaml | grep type'
                'kubectl get jobs'
                
            {
                만약 잡의 포드가 실패한다면 restartPolicy에 따라 포드가 다시 재시작 되거나(OnFailure), 새로운 포드를 다시 생성해 똑같은 작업을
                다시 시도한다.(Never) 포드가 실패하면 기본적으로는 최대 6번을 다시 시도 하지만, 최대 재시도 횟수는 spec.backoffLimit 값에 
                별도로 설정할 수 있따.
            }
            
        이때 3개의 포드를 한꺼번에 생성하지 않고 순차적으로 생성하냐면 이는 잡이 실행할 포드의 개수를 지정하는 spec.parallelism의 값이 기본적으로 1로 
        설정돼 있기 떄문이다. 잡에서 한 번에 포드를 여러 개 생성하여 실행하고 싶다면 parallelism의 값을 적절히 설정하면 된다.  그렇다면 이번에는 
        completion 없이 parallism 값만 3설정해 잡을 실행해보자.
````
job-paralleism.yaml
```yaml
  ...
    name: job-parallelism
  spec:
      parallelism
```
```dockerfile
            'kubectl apply -f job-parallelism.yaml'
            'kubectl get pods'
            
    이번에는 한 번에 3개의 포드가 동시에 생성되고 있음을 확인할 수 있다. spec.completion과 spec.parallelism을 함께 사용하면 잡의 수행 속도를
    적절히 조정할 수 있다. 예를 들어 completion을 8, parallelism을 2로 설정했다고 가정해보자.
```
job-comple-parallel.yaml
```yaml
  ...
    name: job-comple-parallel
  spec:
    completions: 8
    parallelism: 2

```
```dockerfile
    이때 전체적으로는 8개의 포드가 정상적으로 수행돼야만 잡이 성공했다고 여겨지지만, 특정 순간에 동시에 실행될 수 있는 포드의 개수는 2개로 제한돼 있다.
    따라서 포드가 계속해서 생성되어 2개씩 실행될 것이고, 8번째 포드가 정상적으로 종료되는 순간 잡이 성공했다고 간주하기 때문에 포드를 더 이상 생성하지 
    않을 것이다. 
    
        {
            잡의 특정 포드에서 작업이 진행되지 않고 막혀 있는 경우, 잡은 성공이나 실패도 아닌 상태로 오랜 시간 정체되어 있을 것이다. 이러한 상황을 
            방지하기 위해 포드가 실행될 수 있는 최대 시간을 spec.activeDeadlineSeconds 옵션으로 제한할 수 있다. 포드가 이 옵션에 설정된 값보다 
            더 오래 실행될 경우 포드는 강제로 종료되며, 잡은 실패한 상태로 여겨진다. 
        }
        
        
        
            > 크론잡(CronJobs)으로 잡을 주기적으로 실행하기
    크론잡(CronJob)은 잡을 주기적으로 실행하는 쿠버네티스 오브젝트이다. 크론잡을 사용하면 특정 시간 간격으로 잡을 반복적으로 실행할 수 있기 때문에 데이터 
    백업이나 이메일 전송 등의 용도로 사용하기 적합하다. 
    
    크론잡은 리눅스에서 흔히 사요하는 크론(Cron)의 스케쥴 방법을 그대로 사용하기 때문에 크론의 사용방법을 알고 있다면 수월하게 사용할 수 있다.
    1분마다 잡을 실행하는 간단한 크론잡을 생성하기 위해서 아래의 YAML을 작성해보자.
```
cronjob-example.yaml
```yaml
apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: cronJob-example
spec:
  schedule: "*/1 * * * *"       #Job의 실행 주기 
  jobTemplate:                  #실행될 Job의 설정 내용(spec)
    spec:
      template:
        spec:
          restartPolicy: Never
          containers:
          - name: cronjob-example
            image: busybox
            args: ['sh', '-c', 'date']
```
```dockerfile
    먼저 schedule에서는 1분에 한 번씩 실행하라는 의미의 타임 스케쥴을 설정했다. jobTemplate에서는 이전에 잡을 정의할 때 사용했던 것과 동일하게 잡의 
    spec을 그대로 입력하면 된다. 이는 schedule에 설정된 주기마다 jobTemplate의 설정값을 갖는 잡을 실행한다는 의미이다. 따라서 이 YAML 파일로 
    크론잡을 생성하면 1분마다 잡이 생성될 것이다. 
    
            'kubectl apply -f cronjob-example.yaml'
            'kubectl get jobs'
        {
            기본적으로 성공한 잡의 기록은 3개까지, 실패한 잡의 기록은 최대 1개까지만 기록하도록 설정돼 있다. 이 값은 YAML 파일에서 각각 
            spec.successfulJobsHistoryLimit 및 spec.failedJobsHistoryLimit 값을 설정함으로써 변경할 수 있다. 
        }
        
    
                > 2. 데몬셋(DaemonSets)
    데몬셋(DaemonSets)은 쿠버네티스의모든 노드에 동일한 포드를 하나씩 생성하는 오브젝트이다. 데몬셋은 로깅, 모니터링, 네트워킹 등을 위한 에이전트를 각 
    노드에 생성해야할 때 유용하게 사용할 수 있다.
    
    예를 들어, 쿠버네티스 네트워킹을 위한 kube-proxy 컴포넌트나 calico 등의 네트워크 플러그인은 kube-system 네임스페이스에서 데몬셋으로 실행되고 있다.
    calico나 kube-proxy 포드는 쿠버네티스의 오버레이 네트워크를 구성할 때 필수적인 요소이기 때문에 기본적으로 모든 노드에서 에이전트처럼 실행된다.
    
                'kubectl get daemonsets -n kube-system'
    데몬셋은 다른 오브젝트들보다 비교적 간단하기 때문에 어렵지 않게 사용할 수 있다. 모든 노드에 동일한 포드를 하나씩 배치하는 간단한 데몬셋을 생성해 보자. 
```
daemonset-example.yaml
```yaml
apiVersion: appgs/v1
kind: DaemonSet                             # [1]
metadata:
  name: daemonset-example
spec:
  selector:
    matchLabels:
      name: my-daemonset-example            # [2.1] 포드를 생성하기 위한 셀렉터 설정
  template:
    metadata:                               # [2.2] 포드 라벨 설정
      labels:
        name: my-daemonset-example
  spec:
    tolerations:                            # [3] 마스터 노드에도 포드를 생성
    - key: node-role.kubernetes.io/master
      effect: NoSchedule
    conatiners:
    - name: daemonset-example
      image: busybox                        # 테스트를 위해 busybox 이미지 사용
      args: ['tail', '-f', '/dev/null']
        resources:                          # [4] 자원 할당량을 제한
          limits:
            cpu: 100m
            memory: 200Mi
```
```dockerfile
    [1]: 가장 먼저, kind: DaemonSet이라고 명시함으로써 데몬셋을 사용할 것임을 선언한다. 
```