#6. 쿠버네티스 시작하기
###6.1 쿠버네티스를 시작하기 전
```dockerfile
    쿠버네티스는 도커 스웜과 비교해서 쿠버네티스만이 가지는 고유한 특징이 있다.
    
    1. 모든 리소스는 오브젝트 형태로 관리된다.
    쿠버네티스는 대부분의 리소스를 '오브젝트' 형태로 관리한다. 일전에 도커 스웜은 컨테이너의 묶음을 표현하기 위해서 서비스라는 것을 사용했다. 스웜 모드의
    서비스도 컨테이너 리소스의 집합을 정의한 것이기 때문에 일종의 오브젝트라고 볼 수 있다. 그러나 쿠버네티스는 이러한 개념을 더욱 폭넓고 세밀한 단위로
    사용한다. 에를 들어 쿠버네티스는 컨테이너의 집합(Pods), 컨테이너의 집합을 관리하는 컨트롤러(Replica Set), 심지어 사용자 (Service Account),
    노드(Node)까지도 하나의 오브젝트로 사용할 수 있습니다.
    
    'kubectl api-resources' 명령어를 사용하면 꽤 많은 오브젝트를 사용할 수 있음을 알 수 있다.
    
    2. 쿠버네티스는 명령어로도 사용할 수 있지만, YAML을 더 많이 사용한다.
    도커 스웜은 docker service create.. 와 같은 명령어로 컨테이너 서비스를 생성하고 삭제했다. 쿠버네티스에서도 마찬가지로 kubectl이라고 하는 명령어
    로 쿠버네티스를 사용할 수 있으며, 대부분은 kubectl 명령어로 실행할 수 있다.
     스웜 모드에서 스택(stack)을 생성하기 위해서 YAML 파일을 사용했던 것처럼 쿠버네티스도 YAML 파일로 컨테이너 리소스를 생성하거나 삭제할 수 있다. 
    그러나 쿠버네티스에서 YAML 파일의 용도는 컨테이너뿐만 아니라 거의 모든 리소스 오브젝트들에 사용할 수 있다는 것이 큰 특징이다. 
    예를 들어서 컨테이너 자체는 물로니옥, 컨테이너의 설정값(ConfigMap), 비밀값(Secrets) 등 모두 YAML 파일로 정의해서 사용한다. 그리고 쿠버네티스에서
    실제로 서비스를 배포할 때에도 kubectl 명령어가 아닌 여러 개의 YAML 파일을 정의해서 쿠버네티스에 적용하는 방식으로 동작한다. 그래서 쿠버네티스 사용을 
    잘하려면 YAML 파일을 잘 작성하는 것이 도움이 된다.
    
    3. 쿠버네티스는 여러 개의 컴포넌트로 구성되어 있다. 
    쿠버네티스 노드의 역할은 마스터 - 워커로 나뉘어 있다. 마스터 노드는 쿠버네티스가 제대로 동작할 수 있도록 클러스터를 관리하는 역할을 담당하며, 워크 노드
    에서는 애플리케이션 컨테이너가 생성된다. 
     도커 스웜 모드를 사용할 때는 단일 도커 데몬만을 설치해 사용했지만, 쿠버네티스는 도커를 포함한 매우 많은 컴포넌트들이 실행된다. 그러나 쿠버네티스는 도커
    를 포함한 매우 많은 컴포넌트들이 실행된다. 에를 들어 마스터 노드에서는 API 서버(kube-apiserver), 컨트롤러 매니저(kube-controller-manager)
    , 스케쥴러(kube-schedular), DNS서버(coreDNS) 등이 실행되며, 모든 노드에서는 오버레이 네트워크 구성을 위해서 프록시(kube-proxy)와 네트워크
    플러그인(calico, flannel 등)이 실행된다. 이러한 컴포넌트들은 기본적으로 도커 컨테이너로서 실행되고 있다. 마스터 노드에 SSH로 접근해서 'docker ps'
    명령어를 실행해 보면 이를 확인할 수 있다.
      그리고 쿠버네티스 클러스터 구성을 위해서 'kubelet'이라는 에이전트가 모든 노드에서 실행된다. kubelet은 컨테이너의 생성, 삭제뿐만 아니라 마스터와
    워커 노드 간의 통신 역할을 함께 담당하는 매우 중요한 에이전트이다. 따라서 kubelet이 정상적으로 실행되지 않으면 해당 노드는 쿠버네티스와 제대로 연결되지
    않을 수도 있다.
      쿠버네티스의 입장에서 보면 도커 데몬 또한 하나의 컴포넌트이다. 도커 스웜 모드와 달리 쿠버네티스는 도커에 내장된 기능이 아니며, 오히려 컨테이너를 사용
    하기 위해 쿠버네티스가 도커를 이용하는 방식이다. 따라서 쿠버네티스에서 반드시 도커를 사용해야하는 것은 아니며, OCI(Open Container Initative)라는
    컨테이너의 런타임 표준을 구현한 CRI(Container Runtime Interface)를 갖추고 있다면 어떠한 컨테이너를 사용해도 문제는 없다.  
       {
        CRI는 kubelet과 통신하기 위한 인터페이스를 의미하며, CRI를 구현한 컨테이너 런타임이라면 쿠버네티스의 컨테이너로서 사용할 수 있다. 도커 컨테이너
        의 경우 runC 컨테이너 런타임을 제어하는 containerd(컨테이너-디)는 자체적으로 CRI 플러그인을 내장하고 있으므로 도커 엔진만 설치해도 쿠버네티스
        와 별다른 문제 없이 연결해서 사용할 수 있다. CRI를 구현하는 다른 오픈소스로는 cri-o가 있다. 
       }
```

### 6.2 포드(Pod) : 컨테이너를 다루는 기본 단위
#### 6.2.1 포드 사용
```dockerfile
    쿠버네티스에서는 컨테이너 애플리케이션의 기본 단위를 'Pod'라고 부르며, 포드는 1개 이상의 컨테이너로 구성된 컨테이너의 집합이다. 포드는 쿠버네티스에서
    가장 기초적이고 중요한 개념이다. 도커 엔진에서는 기본 단위가 '도커 컨테이너'였고, 스웜 모드에서는 기본 단위가 여러 개의 컨테이너로 구성된 '서비스'였다.
    이와 비슷한 맥락으로 쿠버네티스에서는 컨테이너 애플리케이션을 배포하기 위한 기본 단위로 포드라는 개념을 사용한다. 1개의 포드에는 1개의 컨테이너가 
    존재할 수도 있고, 여러 개의 컨테이너가 존재할 수도 있다. 
      간단한 예시로 Nginx 웹 서비스를 쿠버네티스에서 생성하려면 포드 1개에 Nginx 컨테이너 1개만을 포함해 생성하면 된다. 만약 여러 개를 생성하고 싶다면
      1개의 Nginx 컨테이너가 들어있는 동일한 포드를 여러 개 생성하면 된다. 이처럼 포드는 컨테이너 애플리케이션을 나타내기 위한 기본 구성 요소가 된다. 
```
```yaml
    apiVersion: v1
    kind: Pod
    metadata:
      name: my-nginx-pod
    spec: 
      containers:
        - name: my-nginx-container
          image: nginx:latest
          ports:
            - containerPort: 80
              protocol: TCP
```
```dockerfile
    쿠버네티스의 YAML은 일반적으로 'apiVersion', 'kind', 'metadata', 'spec' 네 가지 항목으로 구성된다. 
    
        - apiVersion : YAML 파일에서 정의한 오브젝트의 API 버전을 나타낸다. 오브젝트의 종류 및 개발 성숙도에 따라 apiVersion의 설정값이 달라질
        수 있다
        - kind : 리소스의 종류를 나타낸다. 위의 YAML 파일에서 생성하려고 하는 거싱 포드이기 때문에 Pod를 입력했다. kind 항목에서 사용할 수 있는
        리소스 오브젝트 종류로는 kubectl api-resources 명령어의 KIND 항목에서 확인할 수 있다. 
        - metadata : 라벨, 주석, 이름 등과 같은 리소스의 부가 정보들을 입력한다. 
        - spec : 리소스를 생성하기 위한 제세한 정보를 입력한다. 위 에시에서는 포드에 실행될 컨테이너 정보를 정의하는 containers 항목을 작성한 뒤, 
        하위 항목인 images에서 사용할 도커 이미지를 지정했다. name 항목에서는 컨테이너의 이름을, ports항목에는 Nginx 컨테이너가 사용할 포트인 80을
        입력했다. 
        
    작성한 YAML 파일은 kubectl apply -f  명령어로 쿠버네티스에 생성할 수 있다. 'kubectl apply -f nginx-pod.yaml' 
    또한 'kubectl get <오브젝트 이름>' 을 사용하면 특정 오브젝트의 목록을 확인할 수 있다. 예를 들어, "kubectl get pods" 명령어는 현재 
    쿠버네티스에 존재하는 포드의 목록을 출력한다.
    
    이 Nginx 포드를 생성할 때, YAML 파일에 사용할 포트(ContainerPort)를 정의하기는 했지만, 아직 외부에서 접근할 수 있는 상태는 아니다. 따라서 포드
    의 Nginx 서버로 요청을 보내려면 포드 컨테이너의 내부 IP로 접근해야 한다.
    kubectl describe 명령어를 사용하면 생성된 리소스의 자세한 정보를 얻어올 수 있다. 예를 들어, 포드의 자세한 정보를 출려하고 싶다면 
    'kubectl describe pods <포드 이름>'처럼 명령어를 사용한다. 해당 명령어를 입력하면 많은 정보가 출력되는데, 그 중 IP는 외부 접근이 가능한 IP가 
    아니라 클러스터 내부에서만 접근할 수 있다. docker run 명령어에서 -p 옵션 없이 컨테이너를 실행한 것과 비슷하다고 생각하면 이해가 쉬울 것이다. 
    
    쿠버네티스 외부 또는 내부에서 포드에 접근하려면 서비스라고 하는 쿠버네티스 오브젝트를 따로 생성해야 한다. (서비스 오브젝트 없이 클러스터 노드에서 해당 
    IP로 HTTP 요청을 던질 수도 있다.) 혹시 이도 어렵다면 'kubectl run -i --tty --rm debug --image=alicek106/ubuntu:curl \
    --restart=Never bash' 로 테스트용 포드를 생성해서 사용할 수도 있다.
    
    포드 컨테이너 내부로 직접 들어가려면 docker exdc와 비슷하게 쿠버네티스에서도 'kubectl exec' 명령으로 포드 컨테이너에 명령어를 전달할 수 있다.
    예를 들어 'kubectl exec -it my-nginx-pod bash'으로 확인을 해볼 수 있다. 또한 도커에서 docker logs 명령어를 사용했던 것처럼 쿠버네티스에서
    도 kubectl logs 명령어로 포드의 로그를 확인할 수 있다. 쿠버네티스의 오브젝트는 'kube delete -f'로 쉽게 삭제할 수 있다. 'kubectl delete \
    -f nginx-pod.yaml'은 nginx-pod.yaml에 정의된 Nginx를 삭제하는 명령어이다. 또는 'kubectl delete pod <포드 이름>'으로도 가능하다.
```

#### 6.2.2 포드 vs. 도커 컨테이너
```dockerfile
    위의 기능들만 본다면 포드는 docker run으로 생성한 단일 nginx 컨테이너와 크게 다르지 않아 보인다. 포드는 컨테이너 IP 주소를 가지고 있어 쿠버네티스
    클러스터 내부에서 접근할 수 있고, kubectl exec 명령어로 포드 컨테이너 내부로 들어갈 수도 있으며, kubectl logs 명령어로 포드의 로그를 확인할 수도
    있기 때문이다. 그렇다면 왜 쿠버네티스는 왜 '도커 컨테이너'가 아니라 '포드'라는 새로운 개념을 사용하는 걸까?
    
    쿠버네티스가 포드를 사용하는 이유는 컨테이너 런타임의 인터페이스 제공 등 여러 가지가 있지만, 그 이유 중 하나는 여러 리눅스 네임스페이스(namespace)를
    공유하는 여러 컨테이너들을 추상화된 집합으로 사용하기 위해서이다. 좀 더 자세히 보면
    'kubectl get pods' 명령어로 포드의 목록을 출력했을 때, READY 항목에서 1/1이라는 출력을 볼 수 있다. 이는 한 개의 포드가 있고 한 개가 정상적으로
    준비됐다는 뜻이다.
    
    실제로 대부분 쿠버네티스의 컨테이너 애플리케이션은 이처럼 1개의 컨테이너로 포드를 구성해서 사용한다. 그러나 1/1이라는 항목에서 알 수 있듯이, 포드는 
    반드시 1개의 컨테이너로 구성해야하는 것은 아니다. 
```
```yaml
    apiVersion: v1
    kind: Pod
    metadata:
      name: my-nginx-pod
    spec: 
      containers:
        - name: my-nginx-container
          image: nginx:latest
          ports:
            - containerPort: 80
              protocol: TCP

        - name: ubuntu-sidecar-container
          image: alicek106/rr-test:curl
          command: ["tail"]
          args: ["-f", "/dev/null"] # 컨테이너가 종료되지 않도록 유지한다.
```
```dockerfile
    YAML에서 대시(-)를 사용하는 항목은 여러 개의 항목을 정의할 수 있음을 의미한다. 예를 들어 위에서 사용한 spec, contianers의 하위 항목은 
    "- name: my-nginx-container"와 같이 대시로 구분되며, 여러 개의 컨테이너를 정의할 수 있다. 따라서 이번에는 포드에 우분투를 하나 더 추가했다.
    
    {
        포드의 YAML 파일에서 사용되는 command와 args는 컨테이너 내부에서 가장 먼저 실행될 프로세스를 지정한다. YAML 파일에서 command를 설정하면
        도커 컨테이너의 Entrypoint로, 포드에서 args를 설정하면 도커 CMD로 치환된다고 생각하면 된다.
    }
    
    앞서 포드를 생성했던 것처럼 'kubectl apply -f' 명령을 사용해서 YAML 파일을 쿠버네티스에 적용하고 시간이 지나면 2개의 컨테이너가 실행 중인 것을 
    알수 있다. 이번에는 'kubectl exec' 명령어를 이용해 새롭게 추가된 우분투 컨테이너의 내부로 들어가보면 kubectl exec, logs 등과 같은 명령어를
    사용할 때는 -c 옵션으 이용해 포드의 어떤 컨테이너에 대해 명령어를 수행할지 명시할 수 있다. 'kubectl exec -it my-nginx-pod -c ubuntu-side\
    car-container bash'와 같음 명령어로 배시 쉘을 실행한다.  ubuntu-sidecar-container 컨테이너 내부에서 로컬호스트로 HTTP 요청을 전송하면
    Nginx서버의 응답이 도착하는 것을 확인할 수 있다. 여기서 이상한 점을 발견할 수 있다. 우분투 컨테이너가 Nginx 서버를 실행하고 있지 않은데도, 우분투
    컨테이너의 로컬 호스트에서 Nginx 서비스로 접근이 가능하기 때문이다. 이는 포드 내의 컨테이너들이 네트워크 네임스페이스 등과 같은 리눅스 네임스페이스를
    공유해서 사용하기 떄문이다. 
    
    {
        네트워크 네임스페이스는 컨테이너의 고유햔 네트워크 환경을 제공해주는 역할을 담당한다. 예를 들어 docker run 명령어로 docker0 브릿지에 연결된
        컨테이너가 생성됐다면, 그 컨테이너는 자기 자신만의 고유한 네트워크 네임스페이스를 가지게 된다. 그렇기 때문에 호스트 및 다른 컨테이너와 다른 고유한
        IP를 유지할 수 있는 것이다.    
    }
    
    docker run --net container:[컨테이너 이름]  옵션을 사용하는 컨테이너 네트워크를 보면 컨테이너 네트워크 네임스페이스를 컨테이너 간의 공유해서 사용
    할 수 있도록 설정하기 때문에 여러 개의 컨테이너가 동일한 네트워크 환경을 가진다. 쿠버네티스의 포드 또한 이러한 리눅스 네임스페이스의 공유 개념을 사용하고
    있다. 그러나 포드가 공유하는 리눅스 네임스페이스에 네트워크 환경만 있는 것은 아니다. 1개의 포드에 호함된 컨테이너들은 여러 개의 리눅스 네임스페이스를 
    공유한다. 
```

#### 6.2.3 완전한 애플리케이션으로서의 포드
```dockerfile
    앞서 말했던 것처럼 실제 쿠버네티스 환경에서는 1개의 컨테이너로 구성된 포드를 사용하는 경우가 많다. 그렇다면 왜 하나의 포드에 여러 개의 컨테이너가 포함
    되어야 하는지가 궁금할 수도 있는데 여기서 한 가지 유의해야 할 점은 '하나의 포드는 하나의 완전한 애플리케이션'이라는 점이다. 따로 부가적인 기능이 필요
    하다면 주 컨테이너에 기능 확장을 위한 추가 컨테이너를 함께 포드에 포함시킬 수 있다. 이렇게 포드에 정의된 부가적인 컨테이너를 사이드카 컨테이너라고 부르며,
    사이드카 컨테이너는 포드 내의 다른 컨테이너와 네트워크 환경 등을 공유하게 된다. 때문에 포드에 포함된 컨테이너들은 모두 같은 워커 노드에서 함께 실행된다.
    
    이러한 구조 및 원리에 따라 포드에 정의된 여러 개의 컨테이너는 하나의 완전한 애플리케이션으로서 동작하게 되는 것이다. 이것이 도커 컨테이너와 
    쿠버네티스의 포드의 차이점이다. 
```

###6.3 레플리카셋(Replica Set) : 일정 개수의 포드를 유지하는 컨트롤러
####6.3.1 레플리카셋을 사용하는 이유
```dockerfile
    쿠버네티스의 기본 단위인 포드는 여러 개의 컨테이너를 추상화해 하나의 애플리케이션으로 동작하도록 만드는 훌륭한 컨테이너 묶음이다. 그러나 YAML에 포드만
    정의해 생성하게 되면 이 포드의 생애 주기(LifeCycle)는 어떻게 될까? 예를들어 2개의 컨테이너가 담겨 있는 포드는 'kubectl delete' 명령어로 포드를
    삭제하면 그 포드의 컨테이너 또한 삭제된 뒤 쿠버네티스에서 영원히 사라지게 된다. 이처럼 YAML 파일에 포드만 정의해 생성할 경우 해당 포드는 오직 쿠버네티
    스 사용자에 의해 관리된다. 단순히 포드의 기능을 테스트하는 드으이 간단한 용도로는 이렇게 사용할수 있을지 모른다. 그렇지만 실제로 외부 사용자의 요청을 
    처리해야하는 마이크로 서비스 구조의 포드라면 이렇게 사용하기 어렵다. 스웜 모드에서 다뤘던 것처럼 마이크로 서비스에서는 여러 개의 동일한 컨테이너를 
    생성한 뒤 외부 요청이 각 컨테이너 적절히 분배될 수 있어야 한다.
    
    쿠버네티스에서는 기본 단위가 포드이기 때문에 동일한 여러 개의 포드를 생성해 외부 요청을 각 포드에 분배하는 방식을 사용해야 할 것이다. 그렇지만 동일한
    여러 개의 포드를 어떻게 생성할 수 있을까? 아마 가장 간단한 방법은 다른 이름을 가지는 여러 개의 포드를 직접 만드는 방식일 것이다.
```
```yaml
    apiVersion: v1
    kind: Pod
    metadata:
      name: my-nginx-pod-a
    spec: 
      containers:
        - name: my-nginx-container
          image: nginx:latest
          ports:
            - containerPort: 80
              protocol: TCP
---
    apiVersion: v1
    kind: Pod
    metadata:
      name: my-nginx-pod-b
    spec:
      containers:
        - name: my-nginx-container
            image: nginx:latest
            ports:
              - containerPort: 80
                protocol: TCP
```
```dockerfile
    그러나 여러 개의 포드를 직접 생성하는 방법은 여러 가지 이유로 적절하지 않다. 우선 동일한 포드의 개수가 많아질수록 이처럼 일일이 정의하는 것은 매우
    비효율적이다. 또한 포드가 어떠한 이유로든지 삭제되거나, 포드가 위치한 노드에 장애가 발생해 더 이상 포드에 접근하지 못하게 됐을 때, 직접 포드를 삭제하고
    다시 생성하지 않는 한 해당 포드는 다시 복구되지 않는다.
    
    아래의 예시에서는 kubectl get pods에 -o wide 옵션을 붙여서 포드가 실행 중인 워커 노드를 확인한 뒤 워커 노드 서버를 종료해봤다. 포드가 생성된
    노드에 장애가 발생하더라도 포드는 다른 노드에서 다시 생성되지 않으며, 포드는 단순히 종료가 된다. 이처럼 포드만 YAML 파일에 정의해 사용하는 방식은 
    여러 가지 한계점이 있다. 따라서 쿠버네티스에서 포드만 정의해서 사용하는 경우는 거의 없으며, 이러한 한계점을 해결해주는 것이 레플리카셋(replicaSet)
    이라는 쿠버네티스 오프젝트이다. 레플리카셋이 수행하는 역할을 간단하게 설명하면 아래와 같다.
    
        1. 정해진 수의 동일한 포드가 항상 실행되도록 관리한다.
        2. 노드 장애 등의 이윯 포드로 사용할 수 없다면 다른 노드에서 포드를 다시 생성한다. 
    
    따라서 동일한 포드를 안정적으로 여러 개 실행할 수도 있고, 워커 노드에 장애가 생기더라도 정해진 개수의 포드를 유지할 수도 있다. 이처럼 레플리카셋이 
    포드를 관리하기 때문에 사용자가 직접 관리할 일은 거의 없다. 
```