#6. 쿠버네티스 시작하기
###6.1 쿠버네티스를 시작하기 전
```dockerfile
    쿠버네티스는 도커 스웜과 비교해서 쿠버네티스만이 가지는 고유한 특징이 있다.
    
    1. 모든 리소스는 오브젝트 형태로 관리된다.
    쿠버네티스는 대부분의 리소스를 '오브젝트' 형태로 관리한다. 일전에 도커 스웜은 컨테이너의 묶음을 표현하기 위해서 서비스라는 것을 사용했다. 스웜 모드의
    서비스도 컨테이너 리소스의 집합을 정의한 것이기 때문에 일종의 오브젝트라고 볼 수 있다. 그러나 쿠버네티스는 이러한 개념을 더욱 폭넓고 세밀한 단위로
    사용한다. 에를 들어 쿠버네티스는 컨테이너의 집합(Pods), 컨테이너의 집합을 관리하는 컨트롤러(Replica Set), 심지어 사용자 (Service Account),
    노드(Node)까지도 하나의 오브젝트로 사용할 수 있습니다.
    
    'kubectl api-resources' 명령어를 사용하면 꽤 많은 오브젝트를 사용할 수 있음을 알 수 있다.
    
    2. 쿠버네티스는 명령어로도 사용할 수 있지만, YAML을 더 많이 사용한다.
    도커 스웜은 docker service create.. 와 같은 명령어로 컨테이너 서비스를 생성하고 삭제했다. 쿠버네티스에서도 마찬가지로 kubectl이라고 하는 명령어
    로 쿠버네티스를 사용할 수 있으며, 대부분은 kubectl 명령어로 실행할 수 있다.
     스웜 모드에서 스택(stack)을 생성하기 위해서 YAML 파일을 사용했던 것처럼 쿠버네티스도 YAML 파일로 컨테이너 리소스를 생성하거나 삭제할 수 있다. 
    그러나 쿠버네티스에서 YAML 파일의 용도는 컨테이너뿐만 아니라 거의 모든 리소스 오브젝트들에 사용할 수 있다는 것이 큰 특징이다. 
    예를 들어서 컨테이너 자체는 물로니옥, 컨테이너의 설정값(ConfigMap), 비밀값(Secrets) 등 모두 YAML 파일로 정의해서 사용한다. 그리고 쿠버네티스에서
    실제로 서비스를 배포할 때에도 kubectl 명령어가 아닌 여러 개의 YAML 파일을 정의해서 쿠버네티스에 적용하는 방식으로 동작한다. 그래서 쿠버네티스 사용을 
    잘하려면 YAML 파일을 잘 작성하는 것이 도움이 된다.
    
    3. 쿠버네티스는 여러 개의 컴포넌트로 구성되어 있다. 
    쿠버네티스 노드의 역할은 마스터 - 워커로 나뉘어 있다. 마스터 노드는 쿠버네티스가 제대로 동작할 수 있도록 클러스터를 관리하는 역할을 담당하며, 워크 노드
    에서는 애플리케이션 컨테이너가 생성된다. 
     도커 스웜 모드를 사용할 때는 단일 도커 데몬만을 설치해 사용했지만, 쿠버네티스는 도커를 포함한 매우 많은 컴포넌트들이 실행된다. 그러나 쿠버네티스는 도커
    를 포함한 매우 많은 컴포넌트들이 실행된다. 에를 들어 마스터 노드에서는 API 서버(kube-apiserver), 컨트롤러 매니저(kube-controller-manager)
    , 스케쥴러(kube-schedular), DNS서버(coreDNS) 등이 실행되며, 모든 노드에서는 오버레이 네트워크 구성을 위해서 프록시(kube-proxy)와 네트워크
    플러그인(calico, flannel 등)이 실행된다. 이러한 컴포넌트들은 기본적으로 도커 컨테이너로서 실행되고 있다. 마스터 노드에 SSH로 접근해서 'docker ps'
    명령어를 실행해 보면 이를 확인할 수 있다.
      그리고 쿠버네티스 클러스터 구성을 위해서 'kubelet'이라는 에이전트가 모든 노드에서 실행된다. kubelet은 컨테이너의 생성, 삭제뿐만 아니라 마스터와
    워커 노드 간의 통신 역할을 함께 담당하는 매우 중요한 에이전트이다. 따라서 kubelet이 정상적으로 실행되지 않으면 해당 노드는 쿠버네티스와 제대로 연결되지
    않을 수도 있다.
      쿠버네티스의 입장에서 보면 도커 데몬 또한 하나의 컴포넌트이다. 도커 스웜 모드와 달리 쿠버네티스는 도커에 내장된 기능이 아니며, 오히려 컨테이너를 사용
    하기 위해 쿠버네티스가 도커를 이용하는 방식이다. 따라서 쿠버네티스에서 반드시 도커를 사용해야하는 것은 아니며, OCI(Open Container Initative)라는
    컨테이너의 런타임 표준을 구현한 CRI(Container Runtime Interface)를 갖추고 있다면 어떠한 컨테이너를 사용해도 문제는 없다.  
       {
        CRI는 kubelet과 통신하기 위한 인터페이스를 의미하며, CRI를 구현한 컨테이너 런타임이라면 쿠버네티스의 컨테이너로서 사용할 수 있다. 도커 컨테이너
        의 경우 runC 컨테이너 런타임을 제어하는 containerd(컨테이너-디)는 자체적으로 CRI 플러그인을 내장하고 있으므로 도커 엔진만 설치해도 쿠버네티스
        와 별다른 문제 없이 연결해서 사용할 수 있다. CRI를 구현하는 다른 오픈소스로는 cri-o가 있다. 
       }
```

### 6.2 포드(Pod) : 컨테이너를 다루는 기본 단위
#### 6.2.1 포드 사용
```dockerfile
    쿠버네티스에서는 컨테이너 애플리케이션의 기본 단위를 'Pod'라고 부르며, 포드는 1개 이상의 컨테이너로 구성된 컨테이너의 집합이다. 포드는 쿠버네티스에서
    가장 기초적이고 중요한 개념이다. 도커 엔진에서는 기본 단위가 '도커 컨테이너'였고, 스웜 모드에서는 기본 단위가 여러 개의 컨테이너로 구성된 '서비스'였다.
    이와 비슷한 맥락으로 쿠버네티스에서는 컨테이너 애플리케이션을 배포하기 위한 기본 단위로 포드라는 개념을 사용한다. 1개의 포드에는 1개의 컨테이너가 
    존재할 수도 있고, 여러 개의 컨테이너가 존재할 수도 있다. 
      간단한 예시로 Nginx 웹 서비스를 쿠버네티스에서 생성하려면 포드 1개에 Nginx 컨테이너 1개만을 포함해 생성하면 된다. 만약 여러 개를 생성하고 싶다면
      1개의 Nginx 컨테이너가 들어있는 동일한 포드를 여러 개 생성하면 된다. 이처럼 포드는 컨테이너 애플리케이션을 나타내기 위한 기본 구성 요소가 된다. 
```
```yaml
    apiVersion: v1
    kind: Pod
    metadata:
      name: my-nginx-pod
    spec: 
      containers:
        - name: my-nginx-container
          image: nginx:latest
          ports:
            - containerPort: 80
              protocol: TCP
```
```dockerfile
    쿠버네티스의 YAML은 일반적으로 'apiVersion', 'kind', 'metadata', 'spec' 네 가지 항목으로 구성된다. 
    
        - apiVersion : YAML 파일에서 정의한 오브젝트의 API 버전을 나타낸다. 오브젝트의 종류 및 개발 성숙도에 따라 apiVersion의 설정값이 달라질
        수 있다
        - kind : 리소스의 종류를 나타낸다. 위의 YAML 파일에서 생성하려고 하는 거싱 포드이기 때문에 Pod를 입력했다. kind 항목에서 사용할 수 있는
        리소스 오브젝트 종류로는 kubectl api-resources 명령어의 KIND 항목에서 확인할 수 있다. 
        - metadata : 라벨, 주석, 이름 등과 같은 리소스의 부가 정보들을 입력한다. 
        - spec : 리소스를 생성하기 위한 제세한 정보를 입력한다. 위 에시에서는 포드에 실행될 컨테이너 정보를 정의하는 containers 항목을 작성한 뒤, 
        하위 항목인 images에서 사용할 도커 이미지를 지정했다. name 항목에서는 컨테이너의 이름을, ports항목에는 Nginx 컨테이너가 사용할 포트인 80을
        입력했다. 
        
    작성한 YAML 파일은 kubectl apply -f  명령어로 쿠버네티스에 생성할 수 있다. 'kubectl apply -f nginx-pod.yaml' 
    또한 'kubectl get <오브젝트 이름>' 을 사용하면 특정 오브젝트의 목록을 확인할 수 있다. 예를 들어, "kubectl get pods" 명령어는 현재 
    쿠버네티스에 존재하는 포드의 목록을 출력한다.
    
    이 Nginx 포드를 생성할 때, YAML 파일에 사용할 포트(ContainerPort)를 정의하기는 했지만, 아직 외부에서 접근할 수 있는 상태는 아니다. 따라서 포드
    의 Nginx 서버로 요청을 보내려면 포드 컨테이너의 내부 IP로 접근해야 한다.
    kubectl describe 명령어를 사용하면 생성된 리소스의 자세한 정보를 얻어올 수 있다. 예를 들어, 포드의 자세한 정보를 출려하고 싶다면 
    'kubectl describe pods <포드 이름>'처럼 명령어를 사용한다. 해당 명령어를 입력하면 많은 정보가 출력되는데, 그 중 IP는 외부 접근이 가능한 IP가 
    아니라 클러스터 내부에서만 접근할 수 있다. docker run 명령어에서 -p 옵션 없이 컨테이너를 실행한 것과 비슷하다고 생각하면 이해가 쉬울 것이다. 
    
    쿠버네티스 외부 또는 내부에서 포드에 접근하려면 서비스라고 하는 쿠버네티스 오브젝트를 따로 생성해야 한다. (서비스 오브젝트 없이 클러스터 노드에서 해당 
    IP로 HTTP 요청을 던질 수도 있다.) 혹시 이도 어렵다면 'kubectl run -i --tty --rm debug --image=alicek106/ubuntu:curl \
    --restart=Never bash' 로 테스트용 포드를 생성해서 사용할 수도 있다.
    
    포드 컨테이너 내부로 직접 들어가려면 docker exdc와 비슷하게 쿠버네티스에서도 'kubectl exec' 명령으로 포드 컨테이너에 명령어를 전달할 수 있다.
    예를 들어 'kubectl exec -it my-nginx-pod bash'으로 확인을 해볼 수 있다. 또한 도커에서 docker logs 명령어를 사용했던 것처럼 쿠버네티스에서
    도 kubectl logs 명령어로 포드의 로그를 확인할 수 있다. 쿠버네티스의 오브젝트는 'kube delete -f'로 쉽게 삭제할 수 있다. 'kubectl delete \
    -f nginx-pod.yaml'은 nginx-pod.yaml에 정의된 Nginx를 삭제하는 명령어이다. 또는 'kubectl delete pod <포드 이름>'으로도 가능하다.
```

#### 6.2.2 포드 vs. 도커 컨테이너