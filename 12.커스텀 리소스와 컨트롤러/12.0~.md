```dockerfile
                > 커스텀 리소스와 컨트롤러
                
   쿠버네티스에서 자주 사용하는 포드, 디플로이먼트, 서비스 등은 모두 쿠버네티스에서 자체적으로 제공하는 리소스 종류이다. 이러한 리소스들은 쿠버네티스의 필수적인
   요소이기 때문에 쿠버네티스를 설치하기만 하면 기본적으로 사용할 수 있다. 그런데 쿠버네티스에서는 포드와 같이 기본적인 리소스 외에도 직접 리소스의 종류를
   정의해 사용할 수도 있는데, 이를 커스텀 리소스(Custom Resource)라고 부른다. 
   커스텀 리소스에 대한 개념 자체는 어렵지 않지만, 커스텀 리소스를 제대로 사용하려면 컨트롤러라는 별도의 컴포넌트를 이해하고 구현할 수 있어야 한다. 쿠버네티스의
   컨트롤러는 클라우드 네이티브 인프라스트럭처(Cloud Native Infrastructure) 생태계에서 자주 쓰이는 개념을 내포하고 있기 때문에 쿠버네티스를 깊게 
   이해하려면 컨트롤러에 관련된 개념을 이해하고 넘어가는 것이 좋다.
   
            > 1. 쿠버네티스 컨트롤러개념과 동작 방식
        > 명령형(Imperative) vs. 선언적(Declarative)
    지금까지 천천히 공부했다면 쿠버네티스와 도커에서 어떠한 리소스를 생성하는 방법이 꽤 다르다는 것을 느꼈을 수 있다. 예를 들어, 도커에서 컨테이너를 생성할
    때는 단순히 docker run 명령어를 사용해 컨테이너를 생성했지만, 쿠버네티스에서는 kubectl apply -f 명령어로 디플로이먼트를 생성하면 레플리카셋이
    포드를 생성하고는 했다. 
    docker run처럼 특정 명령을 처리하는 주체와 통신해 그 작업을 수행하고 그 결괏값을 돌려받는 방식을 쿠버네티스에서는 명령형(Imperative)이라고 말한다.
    그뿐만 아니라 지금까지 포드를 생성할 때 가끔 kubectl run 명령어를 사용하고는 했는데, 이 또한 명령형 방식에 속한다. 간단히 생각해서 도커 데몬을 
    익히기 위해 사용했던 대부분의 명령어가 명령형 방식이라고 생각하면 된다.
    
    쿠버네티스는 이와 반대되는 선언형(Declartive) 방식을 지향한다. 선언형 방식은 최종적으로 도달해야하는 바람직한 상태(Desired State)를 여러분이 
    정의한 뒤, 현재 상태(Current State)가 바람직한 상태와 다를 경우 이를 일치하도록 만드는 방법이다. 지금까지 사용해 왔던 'kubectl apply' 명령어가
    바로 선언형 방식의 대표적인 예시이다. 'kubectl apply -f' 뒤에 따라오는 YAMl 파일은 '최종적으로 도달해야 하는 상태'를 의미하며, 쿠버네티스는
    현재 상태가 해당 YAML 파일과 일치하도록 특정 동작을 수행한다. 
    
    예를 들어, kubectl 명령어로 A라는 리소스를 생성하도록 쿠버네티스에게 명령해야 한다고 가정해보자. 쿠버네티스는 내부적으로 선언형 방식을 지향하지만, 
    사용자가 선택해 사용할 수 있도록 명령형, 선언형 모두 제공한다. 두 방식을 사용할 때 각각 어떻게 다르게 동작하는지 간단히 살펴보자. 
    지금까지 사용해 본 적은 없지만, 명령형 방식의 대표적인 예로 'kubectl create -f' 명령어가 있다. 이 명령어는 '새로운 리소스를 생성해라'라는 구체적인
    동작을 의미하며, 쿠버네티스가 해당 동작을 수행하도록 명령한다. kubectl run 명령어도 이와 비슷한 맥락으로 '포드를 생성하라'라는 구체적인 동작을 내포
    하고 있다. 만약 kubectl create 혹은 run 명령어를 다시 사용하면 '이미 리소스가 존재합니다. 따라서 새롭게 생성할 수 없습니다.'라는 오류를 반환할
    것이다.
    
        'kubectl create -f completed-pod.yaml' -> ~ created
        'kubectl create -f completed-pod.yaml' -> Error from server (AlreadyExists): error when creating
        
    하지만 선언형은 이와 다르게 동작한다. 'kubectl apply -f ' 명령어는 특정 YAML 파일이 최종적으로 완성돼야하는 상태라는 것을 쿠버네티스에게 알려줄 
    뿐, 실제로 어떠한 동작을 취해야 하는지는 명시하지 않는다. '최종적으로 완성돼야 하는 상태가 되기 위해서 어떠한 동작을 취할지는 쿠버네티스에서 컨트롤러 \
    라고 하는 개체가 내부적으로 결정한다.' 즉, 우리가 'kubectl apply -f' 명령어로 '바람직한 상태'를 정의하면 컨트롤러는 현재 상태가 바람직한 상태가
    되도록 만들 것이다. 
    
        {
            앞서 설명했던 바와 쿠버네티스의 대부분의 상태는 etcd와 같은 분산 코디네이터에 저장돼 있다. 따라서 우리가 정의하는 바람직한 상태 또한 etcd
            에 저장돼 있으며, 컨트롤러는 쿠버네티스 API 서버의 Watch API를 통해 etcd에 저장된 상태 데이터를 받아와 동작을 수행한다. 
        }  
        
    이러한 이유로 쿠버네티스에서는 유독 '바람직한 상태(Desired State)'라는 단어가 자주 등장한다. 예를 들어 디플로이먼트를 생성한 뒤 레플리카셋의 상태를
    확인해 보면 Desired라는 항목이 존재한다. 레플리카셋의 입장에서 바람직한 상태는 '특정 개수의 포드가 생성되어 실행 중인 상태'이다. 만약 사용자가 의도적으로
    포드 중 하나를 삭제하면 레플리카셋은 바람직한 상태를 유지하기 위해 새로운 포드를 생성할 것이다. 레플리카셋이 라벨 셀렉터가 일치하는 포드를 생성할 때에도
    선언형 방식의 일종을 사용하고 있는 셈이다. 
    
        'kubectl get rs'
            NAME            DESIRED     CURRENT     READY       AGE
        [    name    ]      1           1           1           4h57m
    
    대부분의 쿠버네티스 오브젝트는 이러한 원리에 따라 제어된다. 이론적으로 쿠버네티스의 컨트롤러는 모두 개별적으로 존재할 수도 있으나, 쿠버네티스는 전체
    구성의 복잡성을 줄이기 위해 컨트롤러 로직을 쿠버네티스 컨트롤러 매니저라는 하나의 컴포넌트에서 구현해 놓았다. 컨트롤러 매니저 또한 쿠버네티스의 핵심
    컴포넌트이기 때문에 kube-system 네임스페이스에서 포드로 실행 되고 있다. 
    
        'kubectl get pods -n kube-system'
            NAME            READY   STATUS    RESTARTS    AGE
        [    name    ]      1/1    RUNNING      40         46d
        
    컨트롤러 매니저에는 디플로이먼트 컨트롤러, 노드 컨트롤러 등 다양한 컨트롤러가 동시에 실행된다. 이러한 컨트롤러들은 쿠버네티스 리소스의 상태 변화를 감지하고
    적절한 작업을 수행하도록 구현돼 있다. 
    
    
    
                
                > 2. 커스텀 리소스에 대한 개념
    명령형과 선언적 방식의 미묘한 차이를 이해했다면 다음 단계는 선언적 방식의 컨트롤러를 통해 어떻게 커스텀 리소스를 구현할 수 있을지에 대해 알아볼 차례이다.
    하지만 그 전에 쿠버네티스에서 말하는 '커스텀 리소스'가 무엇을 의미하는지, 그리고 어떻게 사용할 수 있는지에 대해 먼저 알고 넘어갈 필요가 있다. 
    커스텀 리소스는 말 그대로 우리가 직접 정의해 사용할 수 있는 사용자 정의 리소스이다. 예를 들어, 우리가 Redis를 커스텀 리소스를 만들었다고 생각해 보자.
    그렇다면 지금까지 사용해 봤던 여러 리소스 제어 방법을 redis라는 리소스에 대해서도 똑같이 사용할 수 있다. 즉, 커스텀 리소스 또한 포드, 디플로이먼트,
    서비스 등과 동일한 리소스의 한 종류로 간주된다. 
    
        'kubectl get redis'
        'kubectl describe redis'
    
    커스텀 리소스를 사용하는 방법에는 여러 가지가 있다. 디플로이먼트, 서비스 등의 오브젝트의 묶음을 커스텀 리소스로 추상화함으로써 쿠버네티스 리소스를 묶어 놓은 
    패키지처럼 사용할 수도 있고, 쿠버네티스와 전혀 상관이 없는 로직을 커스텀 리소스와 연동할 수도 있다. 
    예를 들어, 웹 애플리케이션을 WebApp이라는 이름의 커스텀 리소스로 만들었다면 이 커스텀 이소스에는 프론트엔드 서버, 백엔드 서버, 데이터베이스 디플로이먼트, 
    그리고 각 포드가 서로 통신하기 위한 여러 서비스 리소스를 한꺼번에 생성할 수 있으며, 각 리소스의 생애 주기를 쉽게 관리할 수 있다. 커스텀 리소스를 사용함
    으로써 복잡하고 많은 리소스에 대한 관리의 복잡성을 줄일 수 있으며, 쿠버네티스의 오브젝트를 원하는 대로 확장해 사용할 수 있다.
    
            > 커스텀 리소스를 사용하기 위한 단계      
```