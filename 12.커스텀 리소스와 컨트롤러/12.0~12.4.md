```dockerfile
                > 커스텀 리소스와 컨트롤러
                
   쿠버네티스에서 자주 사용하는 포드, 디플로이먼트, 서비스 등은 모두 쿠버네티스에서 자체적으로 제공하는 리소스 종류이다. 이러한 리소스들은 쿠버네티스의 필수적인
   요소이기 때문에 쿠버네티스를 설치하기만 하면 기본적으로 사용할 수 있다. 그런데 쿠버네티스에서는 포드와 같이 기본적인 리소스 외에도 직접 리소스의 종류를
   정의해 사용할 수도 있는데, 이를 커스텀 리소스(Custom Resource)라고 부른다. 
   커스텀 리소스에 대한 개념 자체는 어렵지 않지만, 커스텀 리소스를 제대로 사용하려면 컨트롤러라는 별도의 컴포넌트를 이해하고 구현할 수 있어야 한다. 쿠버네티스의
   컨트롤러는 클라우드 네이티브 인프라스트럭처(Cloud Native Infrastructure) 생태계에서 자주 쓰이는 개념을 내포하고 있기 때문에 쿠버네티스를 깊게 
   이해하려면 컨트롤러에 관련된 개념을 이해하고 넘어가는 것이 좋다.
   
            > 1. 쿠버네티스 컨트롤러개념과 동작 방식
        > 명령형(Imperative) vs. 선언적(Declarative)
    지금까지 천천히 공부했다면 쿠버네티스와 도커에서 어떠한 리소스를 생성하는 방법이 꽤 다르다는 것을 느꼈을 수 있다. 예를 들어, 도커에서 컨테이너를 생성할
    때는 단순히 docker run 명령어를 사용해 컨테이너를 생성했지만, 쿠버네티스에서는 kubectl apply -f 명령어로 디플로이먼트를 생성하면 레플리카셋이
    포드를 생성하고는 했다. 
    docker run처럼 특정 명령을 처리하는 주체와 통신해 그 작업을 수행하고 그 결괏값을 돌려받는 방식을 쿠버네티스에서는 명령형(Imperative)이라고 말한다.
    그뿐만 아니라 지금까지 포드를 생성할 때 가끔 kubectl run 명령어를 사용하고는 했는데, 이 또한 명령형 방식에 속한다. 간단히 생각해서 도커 데몬을 
    익히기 위해 사용했던 대부분의 명령어가 명령형 방식이라고 생각하면 된다.
    
    쿠버네티스는 이와 반대되는 선언형(Declartive) 방식을 지향한다. 선언형 방식은 최종적으로 도달해야하는 바람직한 상태(Desired State)를 여러분이 
    정의한 뒤, 현재 상태(Current State)가 바람직한 상태와 다를 경우 이를 일치하도록 만드는 방법이다. 지금까지 사용해 왔던 'kubectl apply' 명령어가
    바로 선언형 방식의 대표적인 예시이다. 'kubectl apply -f' 뒤에 따라오는 YAMl 파일은 '최종적으로 도달해야 하는 상태'를 의미하며, 쿠버네티스는
    현재 상태가 해당 YAML 파일과 일치하도록 특정 동작을 수행한다. 
    
    예를 들어, kubectl 명령어로 A라는 리소스를 생성하도록 쿠버네티스에게 명령해야 한다고 가정해보자. 쿠버네티스는 내부적으로 선언형 방식을 지향하지만, 
    사용자가 선택해 사용할 수 있도록 명령형, 선언형 모두 제공한다. 두 방식을 사용할 때 각각 어떻게 다르게 동작하는지 간단히 살펴보자. 
    지금까지 사용해 본 적은 없지만, 명령형 방식의 대표적인 예로 'kubectl create -f' 명령어가 있다. 이 명령어는 '새로운 리소스를 생성해라'라는 구체적인
    동작을 의미하며, 쿠버네티스가 해당 동작을 수행하도록 명령한다. kubectl run 명령어도 이와 비슷한 맥락으로 '포드를 생성하라'라는 구체적인 동작을 내포
    하고 있다. 만약 kubectl create 혹은 run 명령어를 다시 사용하면 '이미 리소스가 존재합니다. 따라서 새롭게 생성할 수 없습니다.'라는 오류를 반환할
    것이다.
    
        'kubectl create -f completed-pod.yaml' -> ~ created
        'kubectl create -f completed-pod.yaml' -> Error from server (AlreadyExists): error when creating
        
    하지만 선언형은 이와 다르게 동작한다. 'kubectl apply -f ' 명령어는 특정 YAML 파일이 최종적으로 완성돼야하는 상태라는 것을 쿠버네티스에게 알려줄 
    뿐, 실제로 어떠한 동작을 취해야 하는지는 명시하지 않는다. '최종적으로 완성돼야 하는 상태가 되기 위해서 어떠한 동작을 취할지는 쿠버네티스에서 컨트롤러 \
    라고 하는 개체가 내부적으로 결정한다.' 즉, 우리가 'kubectl apply -f' 명령어로 '바람직한 상태'를 정의하면 컨트롤러는 현재 상태가 바람직한 상태가
    되도록 만들 것이다. 
    
        {
            앞서 설명했던 바와 쿠버네티스의 대부분의 상태는 etcd와 같은 분산 코디네이터에 저장돼 있다. 따라서 우리가 정의하는 바람직한 상태 또한 etcd
            에 저장돼 있으며, 컨트롤러는 쿠버네티스 API 서버의 Watch API를 통해 etcd에 저장된 상태 데이터를 받아와 동작을 수행한다. 
        }  
        
    이러한 이유로 쿠버네티스에서는 유독 '바람직한 상태(Desired State)'라는 단어가 자주 등장한다. 예를 들어 디플로이먼트를 생성한 뒤 레플리카셋의 상태를
    확인해 보면 Desired라는 항목이 존재한다. 레플리카셋의 입장에서 바람직한 상태는 '특정 개수의 포드가 생성되어 실행 중인 상태'이다. 만약 사용자가 의도적으로
    포드 중 하나를 삭제하면 레플리카셋은 바람직한 상태를 유지하기 위해 새로운 포드를 생성할 것이다. 레플리카셋이 라벨 셀렉터가 일치하는 포드를 생성할 때에도
    선언형 방식의 일종을 사용하고 있는 셈이다. 
    
        'kubectl get rs'
            NAME            DESIRED     CURRENT     READY       AGE
        [    name    ]      1           1           1           4h57m
    
    대부분의 쿠버네티스 오브젝트는 이러한 원리에 따라 제어된다. 이론적으로 쿠버네티스의 컨트롤러는 모두 개별적으로 존재할 수도 있으나, 쿠버네티스는 전체
    구성의 복잡성을 줄이기 위해 컨트롤러 로직을 쿠버네티스 컨트롤러 매니저라는 하나의 컴포넌트에서 구현해 놓았다. 컨트롤러 매니저 또한 쿠버네티스의 핵심
    컴포넌트이기 때문에 kube-system 네임스페이스에서 포드로 실행 되고 있다. 
    
        'kubectl get pods -n kube-system'
            NAME            READY   STATUS    RESTARTS    AGE
        [    name    ]      1/1    RUNNING      40         46d
        
    컨트롤러 매니저에는 디플로이먼트 컨트롤러, 노드 컨트롤러 등 다양한 컨트롤러가 동시에 실행된다. 이러한 컨트롤러들은 쿠버네티스 리소스의 상태 변화를 감지하고
    적절한 작업을 수행하도록 구현돼 있다. 
    
    
    
                
                > 2. 커스텀 리소스에 대한 개념
    명령형과 선언적 방식의 미묘한 차이를 이해했다면 다음 단계는 선언적 방식의 컨트롤러를 통해 어떻게 커스텀 리소스를 구현할 수 있을지에 대해 알아볼 차례이다.
    하지만 그 전에 쿠버네티스에서 말하는 '커스텀 리소스'가 무엇을 의미하는지, 그리고 어떻게 사용할 수 있는지에 대해 먼저 알고 넘어갈 필요가 있다. 
    커스텀 리소스는 말 그대로 우리가 직접 정의해 사용할 수 있는 사용자 정의 리소스이다. 예를 들어, 우리가 Redis를 커스텀 리소스를 만들었다고 생각해 보자.
    그렇다면 지금까지 사용해 봤던 여러 리소스 제어 방법을 redis라는 리소스에 대해서도 똑같이 사용할 수 있다. 즉, 커스텀 리소스 또한 포드, 디플로이먼트,
    서비스 등과 동일한 리소스의 한 종류로 간주된다. 
    
        'kubectl get redis'
        'kubectl describe redis'
    
    커스텀 리소스를 사용하는 방법에는 여러 가지가 있다. 디플로이먼트, 서비스 등의 오브젝트의 묶음을 커스텀 리소스로 추상화함으로써 쿠버네티스 리소스를 묶어 놓은 
    패키지처럼 사용할 수도 있고, 쿠버네티스와 전혀 상관이 없는 로직을 커스텀 리소스와 연동할 수도 있다. 
    예를 들어, 웹 애플리케이션을 WebApp이라는 이름의 커스텀 리소스로 만들었다면 이 커스텀 이소스에는 프론트엔드 서버, 백엔드 서버, 데이터베이스 디플로이먼트, 
    그리고 각 포드가 서로 통신하기 위한 여러 서비스 리소스를 한꺼번에 생성할 수 있으며, 각 리소스의 생애 주기를 쉽게 관리할 수 있다. 커스텀 리소스를 사용함
    으로써 복잡하고 많은 리소스에 대한 관리의 복잡성을 줄일 수 있으며, 쿠버네티스의 오브젝트를 원하는 대로 확장해 사용할 수 있다.
    
    
    
            > 커스텀 리소스를 사용하기 위한 단계
    커스텀 리소스는 이전에 없던 쿠버네티스 리소스의 종류를 새롭게 생성하는 것이기 때문에 쿠버네티스에 자체적으로 내장된 리소스를 사용하는 것보다는 조금
    더 복잡한 단계를 거쳐야 한다. 커스텀 리소스를 사용하기 위한 단계를 보면 아래와 같다. 
        
        1. 현재 상태를 커스텀 리소스에 대한 바람직한 상태로 변화시킬 수 있는 컨트롤러를 구현하고, 컨트롤러를 실행한다.
        2. 커스텀 리소스의 상세 정보를 정의하는 CRD(Custom Resource Definition) 리소스를 생성한다.
        3. CRD에 정의된 데이터에 맞춰 커스텀 리소스를 생성한다.
        4. 1번에서 실행한 컨트롤러는 커스텀 리소스의 생성을 감지하고, 커스텀 리소스가 원하는 바람직한 상태가 되도록 적절한 작업을 수행한다.
        
    
    
    
        > 3. 커스텀 리소스를 정의하기 위한 CRD(Custom Resource Definition)
    쿠네티스에서 커스텀 리소스는 customresourcedefinition이라는 오브젝트를 통해 정의할 수 있다. 하지만 오브젝트 이름이 너무 길기 때문에 crd
    (CRD: Custom Resource Definition)라는 이름으로 줄여서 부르는 것이 일반적이며, kubectl get crd 명령어를 통해 그 목록을 확인할 수 있다. 
    kubeadm이나 kops로 설치한 쿠버네티스라면 네트워크 플러그인을 위한 커스텀 리소스가 기본적으로 존재할 것이다.
    
        'kubectl get crd'
        
    CRD(Custom Resource Definition)라는 이름이 의미하는 것처럼 CRD는 '커스텀 리소스를 정의'하는 리소스이다. 즉, 커스텀 리소스를 어떻게 사용할지
    쿠버네티스에 등록하는 선언적인 리소스일 뿐, CRD 자체가 커스텀 리소스를 의미하는 것은 아니다. CRD를 생성한 다음 해당 CRD의 규격에 맞는 커스텀 리소스를
    생성해야만 비로소 의미를 갖는다. 프로그래밍에서 클래스와 인스턴스의 관계처럼, CRD와 커스텀 리소스는 명확히 다르다는 사실에 유의해야 한다.
    CRD 또한 쿠버네티스 오브젝트이기 때문에, 아래처럼 YAML파일에 정의해 생성할 수 있다. CRD에서는 더 많은 항목을 설정할 수 있지만, 여기서는 간단한 
    예시만 표시했다.
```
```yaml
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: alices.k106.com         #1. CRD의 이름
spec:
  group: k106.com               #2. 커스텀 리소스의 API 그룹
  version: v1alpha1             #   커스텀 리소스의 API 버전
  scope: Namespaced             #   커스텀 리소스가 네임스페이스에 속하는지 여부
  name: 
    plural: alices              #3. 커스텀 리소스의 이름(복수형)
    singular: alice             #   커스텀 리소스의 이름(단수형)
    kind: Alice                 #   YAML 파일 등에서 사용될 커스텀 리소스의 Kind
    shortName: ['ac']           #   커스텀 리소스 이름의 줄임말
  validation:
    openAPIV3Schema:            #4. 커스텀 리소스의 데이터를 정의
      required: ['spec']        #   커스텀 리소스에는 반드시 'spec'이 존재해야 한다.
      properties:                 #   커스텀 리소스에 저장될 데이터 형식을 정의
        spec:
          required: ['myvalue']
          properties:
            myvalue:
              type: "string"
              minimum: 1
```
```dockerfile
    상당히 복잡해 보이는 YAML 파일이지만, 각 항목을 하나씩 이해해보자. 
    
        1. metadata.name : 
           metadata:
            name: alices.k106.com #1. CRD의 이름
        CRD의 이름을 지정한다. CRD의 이름은 반드시 spec.names.plural + "." + spec.group 형태여야 한다. 위 예시는 alice+"."+k106.com
        => alice.k106.com으로 설정했다.
        
        2. spec.group.version :
            spec:
              group: k106.com               #2. 커스텀 리소스의 API 그룹
              version: v1alpha1             #   커스텀 리소스의 API 버전
              scope: Namespaced             #   커스텀 리소스가 네임스페이스에 속하는지 여부
        이 CRD를 통해 생성될 커스텀 리소스가 속할 API 그룹과 버전을 설정한다. 일반적으로 리소스 버전은 <API 그룹/버전> 형태로 사용되기 때문에 이 CRD로
        부터 커스텀 리소스 생성하려면 다음과 같이 YAML 파일을 작성해야 할 것이다. 
        apiVersion: k106.com/v1alpha1
        kind: Alice
        ...
        
        3. spec.names : 
             name: 
                plural: alices              #3. 커스텀 리소스의 이름(복수형)
                singular: alice             #   커스텀 리소스의 이름(단수형)
                kind: Alice                 #   YAML 파일 등에서 사용될 커스텀 리소스의 Kind
                shortName: ['ac']           #   커스텀 리소스 이름의 줄임말
        커스텀 리소스를 지칭할 이름을 설정한다. plural은 커스텀 리소스의 복수형을, singular는 단수형을 의미한다. kind는 YAML 등에서 Kind 항목에서
        커스텀 리소스를 나타낼 때 사용할 이름을, shortNames는 커스텀 리소스를 줄여서 부를 이름을 설정한다. 포드에서의 사용 예시와 비교하면 아래와 같다.
```
|     \      |    포드의 사용 예시     |    위 CRD의 사용 예시    |
|:----------:|:----------------:|:------------------:|
|    복수형     | kubectl get pods | kubectl get alices |
|    단수형     | kubectl get pod  | kubectl get alice  |
| 줄여서 부르는 이름 |  kubectl get po  |   kubectl get ac   |
| YAML 파일 예시 |    kind: Pod     |    kind: Alice     |
```dockerfile
        4. spec.validation : 
            validation:
                openAPIV3Schema:            #4. 커스텀 리소스의 데이터를 정의
                  required: ['spec']        #   커스텀 리소스에는 반드시 'spec'이 존재해야 한다.
                  properties:                 #   커스텀 리소스에 저장될 데이터 형식을 정의
                    spec:
                      required: ['myvalue']
                      properties:
                        myvalue:
                          type: "string"
                          minimum: 1
        
        이 항목에서는 실제로 커스텀 리소스에 어떠한 데이터가 저장돼야 하며, 어떠한 항목이 반드시 설정돼야 하는지 정의한다. 위 예시에서는 항목이 반드시 설정
        돼야 하는지 정의한다. 위 예시에서는 required: ["spec"]을 통해 '커스텀 리소스에는 반드시 spec이라는 항목이 있어야 한다'는 것을 명시하고 있다.
        또하나 spec의 하위에 반드시 myvalue라는 항목이 있어야 하며, 이 값은 문자열(string)이어야 한다.
        이러한 CRD 설정값들을 모두 만족하는 커스텀 리소스의 YAML 파일은 최종적으로 아래와 같이 완성할 수 있다. 
```
```yaml
apiVersion: k106.com/v1alpha1
kind: Alice
metadata:
  name: my-custom-resource
spec:
  myvalue: "This is my value"
```
```dockerfile
    우선 CRD를 정의하는 YAML 파일을 통해 새로운 CRD를 생성해 보자.
        'kubectl apply -f my-crd-example.yaml'
        'kubectl get crds'
    CRD를 통해 Alice라는 커스텀 리소스를 사용할 것이라고 쿠버네티스에 등록했기 때문에 이제서야 커스텀 리소스를 생성할 수 있는 상태가 됐다. 앞서 작성했던
    my-cr-example.yaml 파일로 커스텀 리소스를 생성해보자.
    
        'kubectl apply -f my-cr-example.yaml'
    드디어 커스텀 리소스를 생성했다. 이전에 설명했던 것처럼 커스텀 리소스에 대해서 'kubectl get'이나 'kubectl describe' 등의 명령어를 똑같이 사용할 
    수 있다. 
    
        'kubectl get alices'
        'kubectl get ac'
    
    
            > 4. 커스텀 리소스와 컨트롤러
    CRD로부터 커스텀 리소스를 생성했다고 하더라도 이것만으로는 큰 의미를 갖지 않는다. 커스텀 리소스 그 자체는 etcd에 저장된 단순한 데이터일 뿐, 실제로
    동작하고 있는 포드나 서비스는 아니기 때문이다. 커스텀 리소스를 생성했을 때 특정 동작을 수행하도록 정의하는 컨트롤러를 별도로 구현해야만 커스텀 리소스가
    비로소 의미를 갖게 된다. 
    예를 들어, 레플리카셋의 목적은 '라벨 셀렉터가 일치하는 일정 개수의 포드를 생성하는 것' 이었고, 이를 위한 동작은 컨트롤러 매니저라는 컴포넌트 내부에서 수
    행된다. 이처럼 커스텀 리소스가 어떠한 목적을 위해 생성되는지 비즈니스 로직으로 구현해 놓은 별도의 컨트롤러가 필요하다. 이 비즈니스 로직은 커스텀 리소스가
    원하는 바람직한 상태를 계속해서 유지하도록 만드는 소스 코드로 구현되어야 한다.
    
    커스텀 리소스를 위한 컨트롤러가 어떻게 동작하는지 보면 아래와 같다.
    [custom resource definition (1. 커스텀 리소스를 정의하는 CRD 생성)] -> 2. 커스텀 리소스 생성 -> [alice 커스텀 리소스] -> 3. 생성 감지
    -> [Alice 커스텀 리소스를 위한 컨트롤러] -> 4.커스텀 리소스가 Desired-state가 되도록 특정 동작을 수행 
    
    우리가 직접 구현한 컨트롤러는 API 서버의 Watch를 통해 새로운 커스텀 리소스가 생성됐다는 것을 감지하고, 커스텀 리소스가 원하는 바람직한 상태가 되도록
    특정 동작을 수행한다. 이때 바람직한 상태는 우리가 커스텀 리소스의 역할을 어떻게 정의하느냐에 달려있다. 바람직한 상태가 alice와 bob이라는 두 개의 
    포드가 존재하는 것일 수도 있고, 웹 서버 구축을 위한 여러 개의 서버 포드와 서비스가 존재하는 것일 수도 있으며, AWS에서 EC2 인스턴스를 새롭게 하나 생성하는
    것일 수도 있다. 이처럼 현재 상태가 바람직한 상태가 되도록 특정 동작을 수행하는 것을 쿠버네티스에서는 Reconcile이라고 부른다. 레플리카셋으로부터 생성된
    포드를 일부러 하나 삭제하면 즉시 그 자리에 새로운 포드를 새롭게 생성해 바람직한 상태를 유지하는 것도 Reconcile의 일종으로 볼 수 있다.  
    
    그리고 이러한 일련의 동작을 통해 CRD를 사용할 수 있도록 컨트롤러를 구현하는 방법을 오퍼레이터(Operator) 패턴이라고 부러며, 쿠버네티스의 기능을 확장할 
    때 매우 중요하게 여겨지는 원리 중 하나이다. 대부분의 유명한 오픈소스들은 리소스 관리의 복잡성을 줄이기 위해 오퍼레이터 패턴과 커스텀 리소스를 통해
    사용할 수 있도록 제공되고 있다.
    
    하지만 이러한 컨트롤러의 동작 원리를 처음부터 직접 구현하는 것은 매우 어렵다. 위와 같이 컨트롤러의 기본적인 동작만을 구현하려 해도 쿠버네티스의 API를
    제대로 알고 소스 코드로 구현해야 하는데, 이 과정이 생각보다 복잡하기 때문이다. 그래서 컨트롤러를 쉽게 개발할 수 있도록 도와주는 Operator SDK나 
    KubeBuilder와 같은 다양한 프레임워크가 제공되고 있기 때문에, Reconcile에서 어떠한 동작을 수행할 것인지 만을 구현함으로써 쉽게 컨트롤러를 개발할 수 있다.
    
```